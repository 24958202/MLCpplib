{
    "Group 1": [
        {
            "x": 617,
            "y": 207,
            "height": 940,
            "width": 1816,
            "color": "yellow",
            "title": "",
            "text": "Check library independencies:\nldd /home/ronnieji/lib/nemslib.so\n\ng++ -c -fPIC '/home/ronnieji/lib/lib/mysqldatabase.cpp' -o '/home/ronnieji/lib/lib/mysqldatabase.o' -I/usr/include/ -lmysqlclient -std=c++20\ng++ -shared -o '/home/ronnieji/lib/lib/mysqldatabase.so' '/home/ronnieji/lib/lib/mysqldatabase.o' -I/usr/include/ -lmysqlclient -std=c++20\n\ng++ -c -fPIC '/home/ronnieji/lib/lib/nemslib.cpp' -o '/home/ronnieji/lib/lib/nemslib.o' -I/usr/local/include/eigen3 -I/usr/local/include -lcurl -lsqlite3 -I/usr/include -DBOOST_BIND_GLOBAL_PLACEHOLDERS /usr/local/lib/libgumbo.so -I/usr/include/ -lmysqlclient /home/ronnieji/lib/lib/mysqldatabase.so -O3 -s -fPIE -flto -fcf-protection=full -fstack-protector-strong -fomit-frame-pointer -std=c++20\n\ng++ -shared -o '/home/ronnieji/lib/lib/nemslib.so' '/home/ronnieji/lib/lib/nemslib.o' -I/usr/local/include/eigen3 -I/usr/local/include -lcurl -lsqlite3 -I/usr/include -DBOOST_BIND_GLOBAL_PLACEHOLDERS /usr/local/lib/libgumbo.so -I/usr/include/ -lmysqlclient /home/ronnieji/lib/lib/mysqldatabase.so -O3 -s -fPIE -flto -fcf-protection=full -fstack-protector-strong -fomit-frame-pointer -std=c++20 -fPIC\n\n//new\ng++ -c -fPIC '/home/ronnieji/lib/lib/nemslib.cpp' -o '/home/ronnieji/lib/lib/nemslib.o' -I/usr/local/include/eigen3 -I/usr/local/include -I/usr/include/x86_64-linux-gnu -lcurl -lsqlite3 -DBOOST_BIND_GLOBAL_PLACEHOLDERS /usr/local/lib/libgumbo.so -I/usr/include -lmysqlclient /home/ronnieji/lib/lib/mysqldatabase.so -O3 -s -fPIE -flto -fcf-protection=full -fstack-protector-strong -fomit-frame-pointer -std=c++20 -licu  \n\ng++ -shared -o '/home/ronnieji/lib/lib/nemslib.so' '/home/ronnieji/lib/lib/nemslib.o' -I/usr/local/include/eigen3 -I/usr/local/include -I/usr/include/x86_64-linux-gnu -lcurl -lsqlite3 -DBOOST_BIND_GLOBAL_PLACEHOLDERS /usr/local/lib/libgumbo.so -I/usr/include -lmysqlclient /home/ronnieji/lib/lib/mysqldatabase.so -O3 -s -fPIE -flto -fcf-protection=full -fstack-protector-strong -fomit-frame-pointer -std=c++20 -licuuc -fPIC\n\ng++ -shared -o '/home/ronnieji/lib/lib/nemslib.so' '/home/ronnieji/lib/lib/nemslib.o' -lcurl -lsqlite3 -lmysqlclient /home/ronnieji/lib/lib/mysqldatabase.so -L/usr/lib/x86_64-linux-gnu -licuuc -licui18n -licudata -licutu -licuio -fPIC\n\n//lib\ng++ -c -fPIC '/home/ronnieji/lib/lib/nemslib.cpp' -o '/home/ronnieji/lib/lib/nemslib.o' -I/usr/local/include/eigen3 -I/usr/local/include -I/usr/include/x86_64-linux-gnu -lcurl -lsqlite3 -DBOOST_BIND_GLOBAL_PLACEHOLDERS /usr/local/lib/libgumbo.so -I/usr/include -lmysqlclient /home/ronnieji/lib/lib/mysqldatabase.so '/home/ronnieji/lib/lib/nemslib.so' -O3 -s -fPIE -flto -fcf-protection=full -fstack-protector-strong -fomit-frame-pointer -std=c++20 -licu  \n\ng++ -shared -o '/home/ronnieji/lib/lib/nemslib.so' '/home/ronnieji/lib/lib/nemslib.o' -I/usr/local/include/eigen3 -I/usr/local/include -I/usr/include/x86_64-linux-gnu -lcurl -lsqlite3 -DBOOST_BIND_GLOBAL_PLACEHOLDERS /usr/local/lib/libgumbo.so -I/usr/include -lmysqlclient /home/ronnieji/lib/lib/mysqldatabase.so '/home/ronnieji/lib/lib/nemslib.so' -O3 -s -fPIE -flto -fcf-protection=full -fstack-protector-strong -fomit-frame-pointer -std=c++20 -licuuc -fPIC\n\n//app\ng++ '/home/ronnieji/lib/EnglishWords/wordnet.cpp' -o '/home/ronnieji/lib/EnglishWords/wordnet' \\\n-I/usr/local/include/eigen3 -I/usr/local/include -I/usr/include/x86_64-linux-gnu -lcurl -lsqlite3 \\\n-DBOOST_BIND_GLOBAL_PLACEHOLDERS /usr/local/lib/libgumbo.so -I/usr/include -lmysqlclient \\\n/home/ronnieji/lib/lib/mysqldatabase.so '/home/ronnieji/lib/lib/nemslib.so' -O3 -s -fPIE -flto \\\n-fcf-protection=full -fstack-protector-strong -fomit-frame-pointer -std=c++20 -licuuc -licui18n -licudata\n\n//big \ng++ '/home/ronnieji/lib/MLCpplib-main/cpp.cpp' -o '/home/ronnieji/lib/MLCpplib-main/cpp' -I/usr/local/include/eigen3 -I/usr/local/include -I/usr/include/x86_64-linux-gnu -lcurl -lsqlite3 -DBOOST_BIND_GLOBAL_PLACEHOLDERS /usr/local/lib/libgumbo.so -I/usr/include -O3 -s -fPIE -flto -fcf-protection=full -fstack-protector-strong -fomit-frame-pointer -std=c++20 -licuuc -licui18n -licudata\n\n//with mysql\ng++ '/home/ronnieji/lib/MLCpplib-main/read_englishvoc_mysql.cpp' -o '/home/ronnieji/lib/MLCpplib-main/read_englishvoc_mysql' -I/usr/local/include/eigen3 -I/usr/local/include -lcurl -lsqlite3 -licuuc -licui18n -I/usr/include -DBOOST_BIND_GLOBAL_PLACEHOLDERS /usr/local/lib/libgumbo.so /home/ronnieji/lib/lib/mysqldatabase.so '/home/ronnieji/lib/nemslib.so' '/home/ronnieji/lib/libdict.so' -std=c++20 -O3 -s -fPIE -flto -fcf-protection=full -fstack-protector-strong -fomit-frame-pointer -lmysqlclient\n\n//with mysql -final application:\ng++ '/home/ronnieji/lib/MLCpplib-main/read_englishvoc_mysql.cpp' -o '/home/ronnieji/lib/MLCpplib-main/read_englishvoc_mysql' \\\n    -I/usr/local/include/eigen3 -I/usr/local/include -I/usr/include/x86_64-linux-gnu -I/usr/include -L/usr/local/lib \\\n    -L/home/ronnieji/lib/lib /home/ronnieji/lib/lib/nemslib.so \\\n    -licuuc -licui18n -licudata -licutu -licuio -lcurl -lsqlite3 /usr/local/lib/libgumbo.so \\\n    /home/ronnieji/lib/lib/mysqldatabase.so -lmysqlclient -std=c++20 -O3 -s -fPIE -flto -fcf-protection\n\ng++ '/home/ronnieji/lib/MLCpplib-main/testgpt.cpp' -o '/home/ronnieji/lib/MLCpplib-main/testgpt' -I/usr/local/include/eigen3 -I/usr/local/include -I/usr/include/x86_64-linux-gnu -I/usr/include -L/usr/local/lib     -L/home/ronnieji/lib/lib /home/ronnieji/lib/lib/nemslib.so     -licuuc -licui18n -licudata -licutu -licuio -lcurl -lsqlite3 /usr/local/lib/libgumbo.so     /home/ronnieji/lib/lib/mysqldatabase.so -lmysqlclient -std=c++20 -O3 -s -fPIE -flto -fcf-protection\n\ng++ '/home/ronnieji/lib/db_tools/webcrawler_english_binary.cpp' -o '/home/ronnieji/lib/db_tools/webcrawler_english_binary' -I/usr/include/eigen3 -I/usr/local/include -lcurl -lsqlite3 -I/usr/include -DBOOST_BIND_GLOBAL_PLACEHOLDERS /usr/local/lib/libgumbo.so '/home/ronnieji/lib/lib/mysqldatabase.so' '/home/ronnieji/lib/lib/nemslib.so' '/home/ronnieji/lib/lib/libdict.so' -std=c++20 -licuuc -licui18n -O3 -s -fPIE -flto -fcf-protection=full -fstack-protector-strong -fomit-frame-pointer\n\ng++ '/home/ronnieji/lib/db_tools/webcrawler_wiki_class.cpp' -o '/home/ronnieji/lib/db_tools/webcrawler_wiki_class' -I/usr/local/include/eigen3 -I/usr/local/include -lcurl -lsqlite3 -I/usr/include -DBOOST_BIND_GLOBAL_PLACEHOLDERS /usr/local/lib/libgumbo.so /home/ronnieji/lib/lib/mysqldatabase.so -I/usr/include/ -lmysqlclient -lnlplib -fPIE -pie -fstack-protector -fstack-protector-strong -D_FORTIFY_SOURCE=2 -std=c++20\n\n-I/usr/local/include/eigen3 -I/usr/local/include -lcurl -lsqlite3 -licuuc -licui18n -I/usr/include -DBOOST_BIND_GLOBAL_PLACEHOLDERS /usr/local/lib/libgumbo.so /home/ronnieji/lib/lib/mysqldatabase.so '/home/ronnieji/lib/lib/nemslib.so' '/home/ronnieji/lib/lib/nlplib.so' '/home/ronnieji/lib/lib/libdict.so' -std=c++20 -O3 -s -fPIE -flto -fcf-protection=full -fstack-protector-strong -fomit-frame-pointer\n\ng++ '/home/ronnieji/lib/MLCpplib-main/web/mycgi.cpp' -o '/home/ronnieji/lib/MLCpplib-main/web/mycgi' -I/usr/include/jsoncpp -ljsoncpp -std=c++20\ng++ '/home/ronnieji/lib/MLCpplib-main/web/mycgi.cpp' -o '/home/ronnieji/lib/MLCpplib-main/web/mycgi' -I/usr/include/jsoncpp -L/usr/lib -ljsoncpp -I/usr/include/cgicc -L/usr/lib -lcgicc -std=c++20\n\n//compile the app with opencv\n`pkg-config opencv4 --cflags --libs`\n\n-l/usr/include/opencv4 -lopencv_core -lopencv_highgui -lopencv_imgproc -lopencv_imgcodecs\n\ng++ '/home/ronnieji/lib/MLCpplib-main/webCam.cpp' -o '/home/ronnieji/lib/MLCpplib-main/webCam' -I/usr/local/include/eigen3 -I/usr/local/include -lcurl -lsqlite3 -licuuc -licui18n -I/usr/include -DBOOST_BIND_GLOBAL_PLACEHOLDERS -I/usr/include/opencv4 -lopencv_core -lopencv_highgui -lopencv_imgproc -lopencv_imgcodecs -lopencv_videoio -lopencv_objdetect /usr/local/lib/libgumbo.so /home/ronnieji/lib/lib/mysqldatabase.so '/home/ronnieji/lib/lib/nemslib.so' '/home/ronnieji/lib/lib/nlplib.so' '/home/ronnieji/lib/lib/libdict.so' -std=c++20 -O3 -s -fPIE -flto -fcf-protection=full -fstack-protector-strong -fomit-frame-pointer\n"
        },
        {
            "x": 1362,
            "y": 931,
            "height": 68,
            "width": 742,
            "color": "yellow",
            "title": "",
            "text": "g++ '/home/ronnieji/Downloads/FacialRecog_sdk/sdk/linux/example.cpp' -o '/home/ronnieji/Downloads/FacialRecog_sdk/sdk/linux/example' -I/usr/include/opencv4 -lopencv_core -lopencv_imgproc -lopencv_imgcodecs -I/home/ronnieji/Downloads/FacialRecog_sdk/sdk/linux/include /lib/x86_64-linux-gnu/libssl.so -std=c++20 -lcrypto\n"
        },
        {
            "x": 1069,
            "y": 439,
            "height": 484,
            "width": 674,
            "color": "yellow",
            "title": "",
            "text": "##install OpenCV on linux mint:\n\n## Install minimal prerequisites (Ubuntu 18.04 as reference)\nsudo apt update && sudo apt install -y cmake g++ wget unzip\n \n## Download and unpack sources\nwget -O opencv.zip https://github.com/opencv/opencv/archive/4.x.zip\nunzip opencv.zip\n \n## Create build directory\nmkdir -p build && cd build\n \n## Configure\ncmake ../opencv-4.x\n \n## Build\ncmake --build .\n\n------------------------------------------------------------------------------------------------\n\n## Install minimal prerequisites (Ubuntu 18.04 as reference)\nsudo apt update && sudo apt install -y cmake g++ wget unzip\n \n## Download and unpack sources\nwget -O opencv.zip https://github.com/opencv/opencv/archive/4.x.zip\nwget -O opencv_contrib.zip https://github.com/opencv/opencv_contrib/archive/4.x.zip\nunzip opencv.zip\nunzip opencv_contrib.zip\n \n## Create build directory and switch into it\nmkdir -p build && cd build\n \n## Configure\ncmake -DOPENCV_EXTRA_MODULES_PATH=../opencv_contrib-4.x/modules ../opencv-4.x\n \n## Build\ncmake --build ."
        },
        {
            "x": 587,
            "y": 972,
            "height": 200,
            "width": 250,
            "color": "yellow",
            "title": "",
            "text": "QQ security code:\n\njhymewfbcmrkbgjf"
        },
        {
            "x": 117,
            "y": 582,
            "height": 83,
            "width": 298,
            "color": "yellow",
            "title": "",
            "text": "machine learning tutorials:\n\nhttps://www.geeksforgeeks.org/support-vector-machine-algorithm/"
        },
        {
            "x": 85,
            "y": 831,
            "height": 92,
            "width": 345,
            "color": "yellow",
            "title": "",
            "text": "sudo apt-get install libcurl4-openssl-dev libgumbo-dev libtool m4 automake libicu-dev libcpprest-dev cpprestsdk -y"
        },
        {
            "x": 137,
            "y": 190,
            "height": 1112,
            "width": 1533,
            "color": "yellow",
            "title": "",
            "text": "Install docker on linux mint:\n\n#tag:link:https://www.linuxtechi.com/how-to-install-docker-on-linux-mint/##:~:text=How%20to%20Install%20Docker%20on%20Linux%20Mint%2021,User%20...%206%206%29%20Test%20Docker%20Installation%20#tag:link:\n\n1.sudo apt update\n2.sudo apt install -y apt-transport-https ca-certificates curl gnupg\n3.curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/dockerce.gpg\n4.echo \"deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/dockerce.gpg] https://download.docker.com/linux/ubuntu jammy stable\" | sudo tee /etc/apt/sources.list.d/dockerce.list > /dev/null\n5.sudo apt install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin -y\n6.sudo systemctl status docker\n7.sudo usermod -aG docker $USER\n\nUse docker:\n\n1.build:\ndocker build -t webcrawler_wiki:tag .\n\ncopy the image into the flash disk drive:\n\na.save the image\ndocker save your-image-name:tag > /path/to/save/your-image-name.tar\nb.copy the image to flash drive:\ncp /path/to/your-image-name.tar /path/to/your/flash/disk\n\ncheck existing images:\ndocker image ls\n\n2.load images:\ndocker load < /path/to/your-image-name.tar\n\nTo install and run your Docker image on another Linux computer using the ~/your-image-name.tar file you've transferred, you'll need to have Docker installed on that computer. Once Docker is installed, you can load the image from the tar file and then run it as a container. Here\u2019s how you can do it step-by-step:\n\nStep 1: Install Docker on the Other Linux Computer\nIf Docker is not already installed, you'll need to install it. The installation steps may vary depending on the Linux distribution. Here's how to install Docker on Ubuntu as an example:\n\nUpdate your existing list of packages:\nsudo apt update\nInstall a few prerequisite packages which let apt use packages over HTTPS:\nsudo apt install apt-transport-https ca-certificates curl software-properties-common\nAdd the GPG key for the official Docker repository to your system:\ncurl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -\nAdd the Docker repository to APT sources:\nsudo add-apt-repository \"deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable\"\nUpdate your package database with the Docker packages from the newly added repo:\nsudo apt update\nMake sure you are about to install from the Docker repo instead of the default Ubuntu repo:\napt-cache policy docker-ce\nFinally, install Docker:\nsudo apt install docker-ce\nEnsure Docker is running:\nsudo systemctl status docker\nStep 2: Load the Docker Image from the Tar Archive\nTransfer the ~/your-image-name.tar file to the other computer using a USB drive, network transfer, or any other method.\n\nOn the target computer, navigate to the directory where you've placed the tar file.\n\nLoad the Docker image from the tar file:\n\ndocker load < ~/your-image-name.tar\nThis command reads the tar file from the specified path and loads the Docker image into the local image registry.\n\nStep 3: Run the Docker Image as a Container\nAfter loading the image, you can run it as a container:\n\ndocker run -d --name your-container-name your-image-name:tag\nReplace your-container-name with a name for your container, and your-image-name:tag with the name.\n\nREBUILD image:\ndocker build -t webcrawler_wiki:newtag .\n\n\n////////////////////\ndelete juck images:\ndocker system prune\n\n///\nForce remove an image:\ndocker rmi -f d0a7363126bc\n\n\n"
        },
        {
            "x": 389,
            "y": 646,
            "height": 68,
            "width": 404,
            "color": "yellow",
            "title": "",
            "text": "sudo taskset -c 0,1 '/home/ronnieji/watchdog/procT'"
        },
        {
            "x": 1358,
            "y": 459,
            "height": 241,
            "width": 935,
            "color": "yellow",
            "title": "",
            "text": "Netid State  Recv-Q Send-Q Local Address:Port  Peer Address:PortProcess                                   \nudp   UNCONN 0      0            0.0.0.0:52974      0.0.0.0:*    users:((\"avahi-daemon\",pid=707,fd=14))   \nudp   UNCONN 0      0            0.0.0.0:5353       0.0.0.0:*    users:((\"avahi-daemon\",pid=707,fd=12))   \nudp   UNCONN 0      0      127.0.0.53%lo:53         0.0.0.0:*    users:((\"systemd-resolve\",pid=689,fd=13))\nudp   UNCONN 0      0            0.0.0.0:631        0.0.0.0:*    users:((\"cups-browsed\",pid=1176,fd=7))   \nudp   UNCONN 0      0               [::]:5353          [::]:*    users:((\"avahi-daemon\",pid=707,fd=13))   \nudp   UNCONN 0      0               [::]:57244         [::]:*    users:((\"avahi-daemon\",pid=707,fd=15))   \ntcp   LISTEN 0      151        127.0.0.1:3306       0.0.0.0:*    users:((\"mysqld\",pid=975,fd=23))         \ntcp   LISTEN 0      70         127.0.0.1:33060      0.0.0.0:*    users:((\"mysqld\",pid=975,fd=21))         \ntcp   LISTEN 0      128        127.0.0.1:631        0.0.0.0:*    users:((\"cupsd\",pid=939,fd=7))           \ntcp   LISTEN 0      4096   127.0.0.53%lo:53         0.0.0.0:*    users:((\"systemd-resolve\",pid=689,fd=14))\ntcp   LISTEN 0      128            [::1]:631           [::]:*    users:((\"cupsd\",pid=939,fd=6))   "
        },
        {
            "x": 538,
            "y": 430,
            "height": 157,
            "width": 617,
            "color": "yellow",
            "title": "",
            "text": "##!/bin/bash\n\n## Read each line from file_list.txt\nwhile IFS= read -r url; do\n    ## Download the file using curl\n    curl -O \"$url\"\ndone < file_list.txt\n"
        },
        {
            "x": 491,
            "y": 750,
            "height": 78,
            "width": 270,
            "color": "yellow",
            "title": "",
            "text": "How to find a library in linux:\n\nsudo find / -name <lib name>\n\n"
        },
        {
            "x": 379,
            "y": 793,
            "height": 561,
            "width": 647,
            "color": "yellow",
            "title": "",
            "text": "##include <iostream>\n##include <fstream>\n##include <unistd.h>\n\nbool isProcessRunning(const std::string& pidFile) {\n    std::ifstream file(pidFile);\n    int pid;\n    if (file >> pid) {\n        if (kill(pid, 0) == 0) {\n            return true; // Process with PID is running\n        }\n    }\n    return false; // Process not running\n}\n\nvoid createPIDFile(const std::string& pidFile) {\n    std::ofstream file(pidFile);\n    file << getpid();\n}\n\nint main() {\n    std::string pidFile = \"myprocess.pid\";\n\n    if (isProcessRunning(pidFile)) {\n        std::cout << \"Another instance of the process is already running.\" << std::endl;\n        return 1;\n    }\n\n    createPIDFile(pidFile);\n\n    // Your application logic here\n\n    return 0;\n}"
        },
        {
            "x": 1317,
            "y": 333,
            "height": 590,
            "width": 787,
            "color": "yellow",
            "title": "",
            "text": "Catch keyboard & mouse event:\n\n##include <iostream>\n##include <X11/Xlib.h>\n##include <X11/Xutil.h>\n\nint main() {\n    Display* display = XOpenDisplay(NULL);\n    Window root = DefaultRootWindow(display);\n\n    XEvent event;\n    while (true) {\n        XQueryPointer(display, root, &event.xbutton.root, &event.xbutton.window, &event.xbutton.x_root, &event.xbutton.y_root, &event.xbutton.x, &event.xbutton.y, &event.xbutton.state);\n\n        std::cout << \"Mouse Position: \" << event.xbutton.x_root << \", \" << event.xbutton.y_root << std::endl;\n\n        XNextEvent(display, &event);\n        if (event.type == KeyPress) {\n            char key;\n            KeySym keysym;\n            XLookupString(&event.xkey, &key, 1, &keysym, NULL);\n            std::cout << \"Key Pressed: \" << key << std::endl;\n\n            if (key == 'q') {\n                std::cout << \"Exiting...\" << std::endl;\n                break;\n            }\n        }\n    }\n\n    XCloseDisplay(display);\n\n    return 0;\n}"
        },
        {
            "x": 663,
            "y": 795,
            "height": 164,
            "width": 700,
            "color": "yellow",
            "title": "",
            "text": "Install Json on Linux mint:\n\nsudo apt-get install libjsoncpp-dev\n\nsudo apt-get install libnlohmann-json3-dev\n\nsudo apt-get install libjsoncpp-dev libjsoncpp25 -y\n"
        },
        {
            "x": 1739,
            "y": 755,
            "height": 118,
            "width": 396,
            "color": "yellow",
            "title": "",
            "text": "Install snapd in linux mint:\n1.sudo rm /etc/apt/preferences.d/nosnap.pref\nsudo apt update\n2.sudo apt install snapd -y\n3.sudo snap install mysql-workbench-community"
        },
        {
            "x": 1335,
            "y": 839,
            "height": 361,
            "width": 700,
            "color": "yellow",
            "title": "",
            "text": "sudo mysql -u root -p\nmysql password recovery:\n1.sudo mysql\n2.create users\nALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY 'new_password';\n//create a new user\nCREATE USER 'new_user'@'localhost' IDENTIFIED BY 'password';\n//if you want the user to be able to connect from any host, you can use the following command instead:\nCREATE USER 'new_user'@'%'IDENTIFIED BY 'password';\n3. assign necessary privileges to access database and perform specific operations\nGRANT ALL PRIVILEGES ON database_name.*TO'new_user'@'localhost';\n\n//restart mysql on linux\nsudo systemctl restart mysql\n\nrestart mysql on mac\nsudo /usr/local/mysql/support-files/mysql.server stop\nsudo /usr/local/mysql/support-files/mysql.server start\n\nif you can not find <mysql/mysql.h>\nsudo apt-get install libmysqlclient-dev\n"
        },
        {
            "x": 682,
            "y": 400,
            "height": 200,
            "width": 250,
            "color": "yellow",
            "title": "",
            "text": "ChatGPT corpus:\n1. #tag:link:https://simplemaps.com/resources/free-country-cities#tag:link:\n2.#tag:link:https://www.oxfordlearnersdictionaries.com/wordlists/oxford-phrase-list#tag:link:\n3.#tag:link:https://www.behindthename.com/names#tag:link:\n\n"
        },
        {
            "x": 886,
            "y": 213,
            "height": 934,
            "width": 1355,
            "color": "yellow",
            "title": "",
            "text": "delete from nlp_db.all_voc;\ndelete from nlp_db.learned_voc;\ndelete from nlp_db.db_corpus;\nALTER TABLE nlp_db.all_voc AUTO_INCREMENT = 1;\nALTER TABLE nlp_db.learned_voc AUTO_INCREMENT = 1;\nALTER TABLE nlp_db.db_corpus AUTO_INCREMENT = 1;\n\n\n//////////////////////////////////////////////////////////////\nstd::string query = \"SELECT * FROM nlp_db.all_voc where t_x =? and t_y =? and t_z =?\";\n\nMYSQL_STMT *stmt;\nMYSQL_BIND bind[3]; // 3 parameters\n\n// Initialize the statement\nstmt = mysql_stmt_init(mysql);\n\n// Prepare the statement\nif (mysql_stmt_prepare(stmt, query.c_str(), query.size())) {\n    // Error handling\n    std::cerr << \"Error preparing statement: \" << mysql_stmt_error(stmt) << std::endl;\n    return;\n}\n\n// Bind the parameters\nbind[0].buffer_type = MYSQL_TYPE_STRING;\nbind[0].buffer = (char*)bt1.c_str(); // assume bt1 is a std::string\nbind[0].buffer_length = bt1.size();\n\nbind[1].buffer_type = MYSQL_TYPE_STRING;\nbind[1].buffer = (char*)bt2.c_str(); // assume bt2 is a std::string\nbind[1].buffer_length = bt2.size();\n\nbind[2].buffer_type = MYSQL_TYPE_STRING;\nbind[2].buffer = (char*)bt3.c_str(); // assume bt3 is a std::string\nbind[2].buffer_length = bt3.size();\n\n// Bind the parameters to the statement\nif (mysql_stmt_bind_param(stmt, bind)) {\n    // Error handling\n    std::cerr << \"Error binding parameters: \" << mysql_stmt_error(stmt) << std::endl;\n    return;\n}\n\n// Execute the statement\nif (mysql_stmt_execute(stmt)) {\n    // Error handling\n    std::cerr << \"Error executing statement: \" << mysql_stmt_error(stmt) << std::endl;\n    return;\n}\n\n// Fetch the results\nMYSQL_RES *res;\nMYSQL_ROW row;\n\nif (!(res = mysql_stmt_result_metadata(stmt))) {\n    // Error handling\n    std::cerr << \"Error getting result metadata: \" << mysql_stmt_error(stmt) << std::endl;\n    return;\n}\n\nwhile ((row = mysql_stmt_fetch(stmt))) {\n    // Process the row data\n    //...\n}\n\n// Clean up\nmysql_stmt_close(stmt);"
        },
        {
            "x": 1285,
            "y": 426,
            "height": 558,
            "width": 1208,
            "color": "yellow",
            "title": "",
            "text": "sudo apt-get install build-essential g++ \\\n    libgmp-dev \\\n    libmpfr-dev \\\n    libmpc-dev \\\n    cmake \\\n    autoconf \\\n    pkg-config \\\n    ca-certificates \\\n    libssl-dev \\\n    git \\\n    wget \\\n    curl \\\n    unzip \\\n    language-pack-en \\\n    locales \\\n    locales-all \\\n    libboost-all-dev \\\n    libeigen3-dev \\\n    libsqlite3-dev \\\n    libmysqlclient-dev \\\n    libcurl4-openssl-dev \\\n    libgumbo-dev \\\n    libtool \\\n    m4 \\\n    automake \\\n    libicu-dev \\\n    libcpprest-dev \\\n    libmysqlclient-dev \\\n    libopencv-highgui4.5 \\\n    libopencv-dev \\\n    libopencv-video-dev \\\n    libopencv-imgcodecs-dev \\\n    vim \\\n    gdb \\\n    sqlite3 \\\n    libwxsqlite3-3.0-0 \\\n    libwxsqlite3-3.0-dev \\\n    libsoci-sqlite3-4.0 \\\n    libu2f-udev \\\n    mysql-client-8.0 \\\n    mysql-client-core-8.0 \\\n    mysql-server-8.0 \\\n    mysql-server-core-8.0 \\\n    libsoci-mysql4.0 \\\n    libmysqlcppconn-dev \\\n    libmysqlcppconn7v5 \\\n    libmysql++-dev \\\n    libmysql++3v5 \\\n    libu2f-udev \\\n    libgtkmm-3.0-dev \\\n-y\n    sudo add-apt-repository ppa:savoury1/curl34 -y\n    sudo add-apt-repository ppa:savoury1/build-tools -y\n    sudo add-apt-repository ppa:savoury1/backports -y\n    sudo add-apt-repository ppa:savoury1/python -y \n    sudo add-apt-repository ppa:savoury1/encryption -y\n    sudo apt-get install curl -y\n    sudo rm /etc/apt/preferences.d/nosnap.pref\n    sudo apt update\n    sudo apt install snapd -y"
        },
        {
            "x": 864,
            "y": 287,
            "height": 80,
            "width": 254,
            "color": "yellow",
            "title": "",
            "text": "Flash ios burner:\n\nhttps://etcher.balena.io/"
        },
        {
            "x": 439,
            "y": 552,
            "height": 200,
            "width": 250,
            "color": "yellow",
            "title": "",
            "text": "IP check:\n\n#tag:link:https://www.virustotal.com/gui/ip-address/104.22.5.69#tag:link:\n\nhttps://rdap.arin.net/registry/ip/172.64.154.167"
        },
        {
            "x": 768,
            "y": 412,
            "height": 396,
            "width": 529,
            "color": "yellow",
            "title": "",
            "text": "ollama run llama3:70b\n\nCLI\n\nOpen the terminal and run ollama run llama3\nAPI\n\nExample using curl:\n\ncurl -X POST http://localhost:11434/api/generate -d '{\n  \"model\": \"llama3\",\n  \"prompt\":\"Why is the sky blue?\"\n }'\n\nAPI documentation\nModel variants\n\nInstruct is fine-tuned for chat/dialogue use cases.\n\nExample: ollama run llama3 ollama run llama3:70b\n\nPre-trained is the base model.\n\nExample: ollama run llama3:text ollama run llama3:70b-text\n"
        },
        {
            "x": 1290,
            "y": 479,
            "height": 165,
            "width": 808,
            "color": "yellow",
            "title": "",
            "text": "auto it = std::find_if(in_voc.begin(), in_voc.end(), [](const Mdatatype& s) {\n        return s.word == \"california\"; // Return true if the word is \"california\"\n    });\n    \n    if (it != in_voc.end()) {\n        std::cout << it->word << \" \" << it->word_type << \" \" << it->meaning_en << \" \" << it->meaning_zh << '\\n';\n    }\n-----------------------------------------------------------------------------------------------------------------------------------------\nauto it = std::find_if(in_voc.begin(), in_voc.end(), [&gbl](const Mdatatype& s) -> bool {\n            return s.word == gbl; // Return true if the word is equal to gbl\n        });\n\n        if (it != in_voc.end()) {\n            std::cout << it->word << \" \" << it->word_type << \" \" << it->meaning_en << \" \" << it->meaning_zh << '\\n';\n        }"
        },
        {
            "x": 1468,
            "y": 226,
            "height": 458,
            "width": 539,
            "color": "yellow",
            "title": "",
            "text": "clamscan -r /home\n\n./lynis audit system\n\nps aux\n\n//check who is using the port:\nsudo lsof -i :631\nps -A | grep 631\n\n//check smpt:\nps -A | grep smtpd\n\n//install ufw :\nsudo apt-get install ufw\nsudo service ufw status\n\nsudo ufw default deny outgoing\nsudo ufw default deny incoming\nsudo ufw allow out https\nsudo ufw allow out 53\nsudo ufw allow out 80\n\nnetstat -antop\nnetstat -antop | grep ESTABLISHED\n\n\n\n\n\n"
        },
        {
            "x": 596,
            "y": 80,
            "height": 1198,
            "width": 928,
            "color": "yellow",
            "title": "",
            "text": "Boost\n\n##include <boost/algorithm/string.hpp>\n##include <boost/algorithm/string/split.hpp>\n##include <boost/algorithm/string/classification.hpp>\n\n// Tokenization\nstd::vector<std::string> result;\nboost::algorithm::split(result, strInput, boost::algorithm::is_space(), boost::algorithm::token_compress_off);\n\n// Find and replace\n##include<boost/algorithm/string/replace.hpp>\nboost::algorithm::replace_all(strInput, \"text_to_replace\u201d, \u201creplace_string\");\n\nboost::algorithm::trim(textToTrim);\n\nboost::algorithm::to_lower(textToLower);\n\nboost::algorithm::to_upper(textToUpper);\n\nstd::string text = \"This is the first sentence. This is the second sentence. And this is the third sentence.\";\n\n// Splitting into sentences\nstd::vector<std::string> sentences;\nboost::algorithm::split_sentences(text, std::back_inserter(sentences));\n\n\nEnglish\tremove punctuation\n##include <algorithm>\n##include <cctype>\n##include <string>\n\nstd::string for_topics = \"Some string with punctuation! Right?\";\n//remove punctuation(all punctuations including '-' etc.)\nfor_topics.erase(std::remove_if(for_topics.begin(), for_topics.end(),\n\u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 [](char c) { return std::ispunct(static_cast<unsigned char>(c)); }),\n\u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 for_topics.end());\n\ns_book.erase(std::remove_if(s_book.begin(), s_book.end(),[](char c) { return std::ispunct(static_cast<unsigned char>(c)); }), s_book.end());\n\nChinese remove punctuation\n\n\nLink:\nhttps://www.boost.org/doc/libs/1_83_0/doc/html/string_algo/usage.html\n\n\n##include <boost/algorithm/string/split.hpp>\n##include <boost/algorithm/string/classification.hpp>\n\n##include <algorithm>\n##include <iostream>\n\nint main(int argc, char* argv[]) {\n\u2006 \u2006 \u2006 \u2006 const char str[] = \"This is a long long character array.\"\n\u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \"Please split this character array to sentences!\"\n\u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \"Do you know, that sentences are separated using period,\"\n\u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \"exclamation mark and question mark? :-\";\n\u2006 \u2006 \u2006 \u2006 \n\u2006 \u2006 \u2006 \u2006 using split_iter_t = boost::split_iterator<const char*>;\n\u2006 \u2006 \u2006 \u2006 split_iter_t sentences = boost::make_split_iterator(str, \n\u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 boost::algorithm::token_finder(boost::is_any_of(\"?!.\")));\n\u2006 \u2006 \u2006 \u2006 \n\u2006 \u2006 \u2006 \u2006 for(unsigned int i=1; !sentences.eof(); ++sentences, ++i) {\n\u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 auto range = *sentences;\n\u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 std::cout << \"Sentence ##\" << i << \": \\t\" << range << '\\n';\n\u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 std::cout << \"Sentence has \" << range.size() << \" characters.\\n\";\n\u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 std::cout << \"Sentence has \"\n\u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 << std::count(range.begin(), range.end(), ' ')\n\u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 << \" whitespaces. \\n\\n\";\n\u2006 \u2006 \u2006 \u2006 }\n\n\u2006 \u2006 \u2006 \u2006 return 0;\n}\n\nstd::string input = \"apple,banana,orange,grape\";\nstd::vector<std::string> tokens;\nboost::split(tokens, input, boost::is_any_of(\",\"));\n\n\n##include <iostream>\n##include <vector>\n##include <boost/tokenizer.hpp>\n\nint main() {\n\u2006 \u2006 \u2006 \u2006 std::string str = \"Hello^&*World\";\n\u2006 \u2006 \u2006 \u2006 boost::char_separator<char> sep(\"^&*\");\n\u2006 \u2006 \u2006 \u2006 boost::tokenizer<boost::char_separator<char>> tokens(str, sep);\n\n\u2006 \u2006 \u2006 \u2006 std::vector<std::string> tokenVector(tokens.begin(), tokens.end());\n\n\u2006 \u2006 \u2006 \u2006 for (const auto& token : tokenVector) {\n\u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 std::cout << token << std::endl;\n\u2006 \u2006 \u2006 \u2006 }\n\n\u2006 \u2006 \u2006 \u2006 return 0;\n}"
        },
        {
            "x": 427,
            "y": 590,
            "height": 572,
            "width": 690,
            "color": "yellow",
            "title": "",
            "text": "c++ TTS Linux:\n\nOn Linux, you can use the espeak-ng library to implement a text-to-speech program in C++ using standard C++20. Here's an example:\n\n##include <iostream>\n##include <string>\n##include <espeak-ng/speak_lib.h>\n\nint main() {\n\u2006 \u2006 \u2006 \u2006 std::string text = \"Hello, this is a text-to-speech example using C++20 on Linux.\";\n\n\u2006 \u2006 \u2006 \u2006 // Initialize espeak-ng\n\u2006 \u2006 \u2006 \u2006 espeak_ng_Initialize(NULL, 0, NULL, 0);\n\n\u2006 \u2006 \u2006 \u2006 // Set the text to be spoken\n\u2006 \u2006 \u2006 \u2006 espeak_ng_TTS textToSpeak;\n\u2006 \u2006 \u2006 \u2006 textToSpeak.text = text.c_str();\n\u2006 \u2006 \u2006 \u2006 textToSpeak.length = text.length();\n\u2006 \u2006 \u2006 \u2006 textToSpeak.position = POS_CHARACTER;\n\n\u2006 \u2006 \u2006 \u2006 // Speak the text\n\u2006 \u2006 \u2006 \u2006 espeak_ng_Synth(&textToSpeak, 1, NULL);\n\n\u2006 \u2006 \u2006 \u2006 // Wait for speech to finish\n\u2006 \u2006 \u2006 \u2006 while (espeak_ng_IsPlaying()) {\n\u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 // Do nothing\n\u2006 \u2006 \u2006 \u2006 }\n\n\u2006 \u2006 \u2006 \u2006 // Shutdown espeak-ng\n\u2006 \u2006 \u2006 \u2006 espeak_ng_Terminate();\n\n\u2006 \u2006 \u2006 \u2006 return 0;\n}"
        },
        {
            "x": 777,
            "y": 104,
            "height": 1118,
            "width": 800,
            "color": "yellow",
            "title": "",
            "text": "c++ multi-thread:\n\n##include <iostream>\n##include <thread>\n##include <future>\n\nint function1() {\n\u2006 \u2006 \u2006 \u2006 std::cout << \"Function 1 is running\" << std::endl;\n\u2006 \u2006 \u2006 \u2006 return 42;\n}\n\nint function2() {\n\u2006 \u2006 \u2006 \u2006 std::cout << \"Function 2 is running\" << std::endl;\n\u2006 \u2006 \u2006 \u2006 return 84;\n}\n\nint main() {\n\u2006 \u2006 \u2006 \u2006 std::future<int> result1 = std::async(std::launch::async, function1);\n\u2006 \u2006 \u2006 \u2006 std::future<int> result2 = std::async(std::launch::async, function2);\n\n\u2006 \u2006 \u2006 \u2006 int value1 = result1.get();\n\u2006 \u2006 \u2006 \u2006 int value2 = result2.get();\n\n\u2006 \u2006 \u2006 \u2006 std::cout << \"Function 1 returned: \" << value1 << std::endl;\n\u2006 \u2006 \u2006 \u2006 std::cout << \"Function 2 returned: \" << value2 << std::endl;\n\n\u2006 \u2006 \u2006 \u2006 return 0;\n}\n\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\n\n##include <iostream>\n##include <thread>\n##include <fstream>\n##include <mutex>\n\nstd::mutex fileMutex;\n\nvoid function1() {\n\u2006 \u2006 \u2006 \u2006 fileMutex.lock(); // Lock the mutex to ensure exclusive access to the file\n\u2006 \u2006 \u2006 \u2006 std::ifstream file(\"input.txt\");\n\u2006 \u2006 \u2006 \u2006 std::string line;\n\u2006 \u2006 \u2006 \u2006 while (std::getline(file, line)) {\n\u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 std::cout << \"Function 1: \" << line << std::endl;\n\u2006 \u2006 \u2006 \u2006 }\n\u2006 \u2006 \u2006 \u2006 file.close();\n\u2006 \u2006 \u2006 \u2006 fileMutex.unlock(); // Unlock the mutex after file access is done\n}\n\nvoid function2() {\n\u2006 \u2006 \u2006 \u2006 fileMutex.lock(); // Lock the mutex\n\u2006 \u2006 \u2006 \u2006 std::ifstream file(\"input.txt\");\n\u2006 \u2006 \u2006 \u2006 std::string line;\n\u2006 \u2006 \u2006 \u2006 while (std::getline(file, line)) {\n\u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 std::cout << \"Function 2: \" << line << std::endl;\n\u2006 \u2006 \u2006 \u2006 }\n\u2006 \u2006 \u2006 \u2006 file.close();\n\u2006 \u2006 \u2006 \u2006 fileMutex.unlock(); // Unlock the mutex\n}\n\nint main() {\n\u2006 \u2006 \u2006 \u2006 std::thread t1(function1);\n\u2006 \u2006 \u2006 \u2006 std::thread t2(function2);\n\n\u2006 \u2006 \u2006 \u2006 t1.join();\n\u2006 \u2006 \u2006 \u2006 t2.join();\n\n\u2006 \u2006 \u2006 \u2006 return 0;\n}"
        },
        {
            "x": 393,
            "y": 529,
            "height": 479,
            "width": 844,
            "color": "yellow",
            "title": "",
            "text": "MySql password reovery:\n\nsudo mysql\n\n->\n\n//create the root administrator\nALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY \u2018new password\u2019;\n\n//create a new user\nCREATE USER \u2018new_user\u2019@\u2018localhost\u2019 IDENTIFIED BY \u2018password\u2019;\n\n//if you want the suer to be able to connect from any host, you can use the following command instead:\nCREATE USER \u2018new_user\u2019@\u2018%\u2019 IDENTIFIED BY \u2018password\u2019;\n\n//assign necessary privileges to access databases and perform specific operations\nGRANT ALL PRIVILEGES ON database_name.* TO \u2018new_user\u2019@\u2018localhost\u2019;\n\n//restart mysql on linux\nsudo systemctl restart mysql\n\n//restart mysql on mac\nsudo /usr/local/mysql/support-files/mysql.server stop\nsudo /usr/local/mysql/support-files/mysql.server start\n\nIf you can not find <mysql/mysql.h>\nSudo apt-get install libmysqlclient-dev\n\n"
        },
        {
            "x": 303,
            "y": 322,
            "height": 1032,
            "width": 1202,
            "color": "yellow",
            "title": "",
            "text": "std::unordered_map\n\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\nInsert items into std::unordered_map:\n\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\n##include <iostream>\n##include <unordered_map>\n\nint main() {\n\u2006 \u2006 \u2006 \u2006 std::unordered_map<std::string, int> myMap;\n\n\u2006 \u2006 \u2006 \u2006 // Insert items\n\u2006 \u2006 \u2006 \u2006 myMap[\"apple\"] = 5;\n\u2006 \u2006 \u2006 \u2006 myMap[\"banana\"] = 3;\n\u2006 \u2006 \u2006 \u2006 myMap[\"orange\"] = 7;\n\n\u2006 \u2006 \u2006 \u2006 // Display the map\n\u2006 \u2006 \u2006 \u2006 for (const auto& pair : myMap) {\n\u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 std::cout << pair.first << \": \" << pair.second << std::endl;\n\u2006 \u2006 \u2006 \u2006 }\n\n\u2006 \u2006 \u2006 \u2006 return 0;\n}\n\n/*\n\tother ways to insert data\n*/\n// Inserting data using insert function with std::pair\n\u2006 \u2006 \u2006 \u2006 occupations.insert(std::make_pair(\"John\", \"Engineer\"));\n\u2006 \u2006 \u2006 \u2006 occupations.insert(std::make_pair(\"Alice\", \"Doctor\"));\n\n\u2006 \u2006 \u2006 \u2006 // Inserting data using emplace function\n\u2006 \u2006 \u2006 \u2006 occupations.emplace(\"Bob\", \"Teacher\");\n\n//insert a same structure dataset\nmyMap.insert(new_occupations_from_txt.begin(),new_occupations_from_txt.end());\n\n\nUpdate items in std::unordered_map:\n\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\n\n##include <iostream>\n##include <unordered_map>\n\nint main() {\n\u2006 \u2006 \u2006 \u2006 std::unordered_map<std::string, int> myMap = {{\"apple\", 5}, {\"banana\", 3}, {\"orange\", 7}};\n\n\u2006 \u2006 \u2006 \u2006 // Update item\n\u2006 \u2006 \u2006 \u2006 myMap[\"apple\"] = 8;\n\n\u2006 \u2006 \u2006 \u2006 // Display the updated map\n\u2006 \u2006 \u2006 \u2006 for (const auto& pair : myMap) {\n\u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 std::cout << pair.first << \": \" << pair.second << std::endl;\n\u2006 \u2006 \u2006 \u2006 }\n\n\u2006 \u2006 \u2006 \u2006 return 0;\n}\n\n\nDelete items from std::unordered_map:\n\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\n##include <iostream>\n##include <unordered_map>\n\nint main() {\n\u2006 \u2006 \u2006 \u2006 std::unordered_map<std::string, int> myMap = {{\"apple\", 5}, {\"banana\", 3}, {\"orange\", 7}};\n\n\u2006 \u2006 \u2006 \u2006 // Delete item\n\u2006 \u2006 \u2006 \u2006 myMap.erase(\"banana\");\n\n\u2006 \u2006 \u2006 \u2006 // Display the modified map\n\u2006 \u2006 \u2006 \u2006 for (const auto& pair : myMap) {\n\u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 std::cout << pair.first << \": \" << pair.second << std::endl;\n\u2006 \u2006 \u2006 \u2006 }\n\n\u2006 \u2006 \u2006 \u2006 return 0;\n}\n\n//to erase multiple items\nfor (auto it = myMap.begin(); it != myMap.end(); ) {\n\u2006 \u2006 \u2006 \u2006 if (it->first == nna) {\n\u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 it = myMap.erase(it);\n\u2006 \u2006 \u2006 \u2006 } else {\n\u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 ++it;\n\u2006 \u2006 \u2006 \u2006 }\n}\n\n\nSelect items from std::unordered_map (performing a lookup):\n\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\n##include <iostream>\n##include <unordered_map>\n\nint main() {\n\u2006 \u2006 \u2006 \u2006 std::unordered_map<std::string, int> myMap = {{\"apple\", 5}, {\"banana\", 3}, {\"orange\", 7}};\n\n\u2006 \u2006 \u2006 \u2006 // Select item\n\u2006 \u2006 \u2006 \u2006 std::string key = \"banana\";\n\u2006 \u2006 \u2006 \u2006 if (myMap.contains(key)) {\n\u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 std::cout << \"The value for \" << key << \" is \" << myMap[key] << std::endl;\n\u2006 \u2006 \u2006 \u2006 } else {\n\u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 std::cout << key << \" not found in the map\" << std::endl;\n\u2006 \u2006 \u2006 \u2006 }\n\u2006 \u2006 \u2006 \u2006 return 0;\n}\n\n\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014remove repeated items \u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\n\nstd::unordered_map<std::string,std::string> my_map(vec.begin(),vec.end());\n\u2006 \u2006 \u2006 \u2006 try{\n\u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 std::unordered_set<std::string> unique_keys;\n\u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 for (auto it = my_map.begin(); it != my_map.end(); ) {\n\u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 if (!unique_keys.insert(it->first).second) {\n\u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 it = my_map.erase(it);\u2006 \u2006 // Erase the element and move to the next\n\u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 } else {\n\u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 ++it;\n\u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 }\n\u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 }\n\u2006 \u2006 \u2006 \u2006 }\n\u2006 \u2006 \u2006 \u2006 catch(const std::exception& e){\n\u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 std::cerr << \"Error remove_repeated_items_um: \" << e.what() << std::endl;\n\u2006 \u2006 \u2006 \u2006 }\n\u2006 \u2006 \u2006 \u2006 return my_map;\n\n\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014remove empty items\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\n\nfor (auto it = myMap.begin(); it != myMap.end(); ) {\n\u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 if (it->second.empty()) {\n\u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 it = myMap.erase(it);\n\u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 } else {\n\u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 ++it;\n\u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 }\n\u2006 \u2006 \u2006 \u2006 }\n\n\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\n##include <iostream>\n##include <unordered_map>\n##include <vector>\n\nint main() {\n\u2006 \u2006 \u2006 \u2006 std::unordered_map<std::string, std::vector<int>> myMap;\n\u2006 \u2006 \u2006 \u2006 \n\u2006 \u2006 \u2006 \u2006 myMap[\"apple\"].push_back(5);\n\u2006 \u2006 \u2006 \u2006 myMap[\"apple\"].push_back(7);\n\u2006 \u2006 \u2006 \u2006 myMap[\"apple\"].push_back(9);\n\u2006 \u2006 \u2006 \u2006 \n\u2006 \u2006 \u2006 \u2006 for (const auto& pair : myMap) {\n\u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 std::cout << pair.first << \": \";\n\u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 for (int value : pair.second) {\n\u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 std::cout << value << \" \";\n\u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 }\n\u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 std::cout << std::endl;\n\u2006 \u2006 \u2006 \u2006 }\n\u2006 \u2006 \u2006 \u2006 \n\u2006 \u2006 \u2006 \u2006 return 0;\n}\n\n//\u2014\u2014\u2014\u2014\u2014 sored the items\u2014\u2014\u2014\u2014\n\n##include <iostream>\n##include <unordered_map>\n##include <map>\n##include <string>\n\nstruct Compare {\n\u2006 \u2006 \u2006 \u2006 bool operator()(const std::pair<std::string, int>& a, const std::pair<std::string, int>& b) {\n\u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 return a.second > b.second; // Sort by int value in descending order\n\u2006 \u2006 \u2006 \u2006 }\n};\n\nint main() {\n\u2006 \u2006 \u2006 \u2006 std::unordered_map<std::string, int> myMap = {\n\u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 {\"one\", 1},\n\u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 {\"two\", 2},\n\u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 {\"three\", 3}\n\u2006 \u2006 \u2006 \u2006 };\n\n\u2006 \u2006 \u2006 \u2006 // Create a multimap using the custom comparator\n\u2006 \u2006 \u2006 \u2006 std::multimap<std::string, int, Compare> sortedMap;\n\n\u2006 \u2006 \u2006 \u2006 // Insert key-value pairs from the unordered_map to the multimap\n\u2006 \u2006 \u2006 \u2006 for (const auto& pair : myMap) {\n\u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 sortedMap.insert(pair);\n\u2006 \u2006 \u2006 \u2006 }\n\n\u2006 \u2006 \u2006 \u2006 // Print the sorted map\n\u2006 \u2006 \u2006 \u2006 for (const auto& pair : sortedMap) {\n\u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 std::cout << pair.first << \": \" << pair.second << std::endl;\n\u2006 \u2006 \u2006 \u2006 }\n\n\u2006 \u2006 \u2006 \u2006 return 0;\n}\n\n\u2014\u2014 insert one to another\u2006 \u2006 std::unordered_map<std::string, std::string>\n\n##include <iostream>\n##include <unordered_map>\n##include <string>\n\nint main() {\n\u2006 \u2006 \u2006 \u2006 std::unordered_map<std::string, std::string> map1 = {{\"key1\", \"value1\"}, {\"key2\", \"value2\"}};\n\u2006 \u2006 \u2006 \u2006 std::unordered_map<std::string, std::string> map2 = {{\"key3\", \"value3\"}, {\"key4\", \"value4\"}};\n\n\u2006 \u2006 \u2006 \u2006 map1.insert(map2.begin(), map2.end());\n\n\u2006 \u2006 \u2006 \u2006 // Display the combined map\n\u2006 \u2006 \u2006 \u2006 for (const auto& pair : map1) {\n\u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 std::cout << pair.first << \": \" << pair.second << std::endl;\n\u2006 \u2006 \u2006 \u2006 }\n\n\u2006 \u2006 \u2006 \u2006 return 0;\n}"
        },
        {
            "x": 317,
            "y": 256,
            "height": 943,
            "width": 1513,
            "color": "yellow",
            "title": "",
            "text": "std::vector<std::string>\n\n//find items in the dataset\n//check if gn is in the dataset\nauto it = std::find_if(exclused_words.begin(), exclused_words.end(), [gn](const std::string& s) {\n\u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 return s == gn;\n\u2006 \u2006 });\n\u2006 \u2006 if(it != exclused_words.end()){\n\t//found\n\t\n}\n\n//in a for loop\nfor(const auto& gn : Whatever){\nauto it = std::find_if(exclused_words.begin(), exclused_words.end(), [&gn](const std::string& s) {\n\u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 return s == gn;\n\u2006 \u2006 });\n\u2006 \u2006 if(it != exclused_words.end()){\n\t//found\n\t\n}\n}\n\n//erase items in c++11\nauto it = std::find(get_verbs.begin(),get_verbs.end(), strword);\n\tif(it != get_verbs.end()){\n\t\tget_verbs.erase(it);\n\t}\n\nor:\nfor(auto it = publicV::total_voc.begin(); it != publicV::total_voc.end();){\n\tif(no_repeated_done.find(*it) != no_repeated_done.end()){\n\t\tit = publicV::total_voc.erase(it);\n\t}\n\telse{\n\t\t++it;\n\t}\n}\n\n//erase items gn from std::vector<std::string>persons\npersons_names.erase(std::remove(persons_names.begin(), persons_names.end(), gn), persons_names.end());//remove the item from the list\n\n\n//find all the words before and after the \u201cit\u201d\nauto it = std::find(vb_words.begin(), vb_words.end(), sa);\nif (it != vb_words.end()) {\n\u2006 \u2006 \u2006 \u2006 size_t pos = std::distance(vb_words.begin(), it); // Get the position of the found string\n\n\u2006 \u2006 \u2006 \u2006 // Create sub-vectors for the words before and after the found string\n\u2006 \u2006 \u2006 \u2006 std::vector<std::string> words_before(vb_words.begin(), vb_words.begin() + pos);\n\u2006 \u2006 \u2006 \u2006 std::vector<std::string> words_after(vb_words.begin() + pos + 1, vb_words.end());\n\n\u2006 \u2006 \u2006 \u2006 // Print the words before and after the found string\n\u2006 \u2006 \u2006 \u2006 std::cout << \"Words before: \";\n\u2006 \u2006 \u2006 \u2006 for (const auto& word : words_before) {\n\u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 std::cout << word << \" \";\n\u2006 \u2006 \u2006 \u2006 }\n\u2006 \u2006 \u2006 \u2006 std::cout << std::endl;\n\n\u2006 \u2006 \u2006 \u2006 std::cout << \"Words after: \";\n\u2006 \u2006 \u2006 \u2006 for (const auto& word : words_after) {\n\u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 std::cout << word << \" \";\n\u2006 \u2006 \u2006 \u2006 }\n\u2006 \u2006 \u2006 \u2006 std::cout << std::endl;\n}\n\n/*\n\u2006 \u2006 \u2006 \u2006 remove empty items\n*/\nif(!data.empty()){\n\u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 data.erase(std::remove(data.begin(), data.end(), \"\"), data.end());\n\u2006 \u2006 }\n\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2006 \u2006 map \u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\n\nHere are examples of how to perform the operations you've mentioned using a std::map<std::string, std::string>:\n\n1.Adding items to the map:\nstd::map<std::string, std::string> A;\n\n// Adding items to the map\n\nA[\"key1\"] = \"value1\";\nA[\"key2\"] = \"value2\";\nA[\"key3\"] = \"value3\";\n\nAnother way:\n\nA.insert(std::pair<std::string, std::string>(\u201ckey1\u201d, \u201cvalue1\u201d));\n\n2.Searching items in the map:\n// Searching for an item in the map\n\nstd::string key_to_search = \"key2\";\nauto it = A.find(key_to_search);\nif (it != A.end()) {\n\u2006 \u2006 \u2006 \u2006 std::cout << \"Item found. Key: \" << it->first << \", Value: \" << it->second << std::endl;\n} else {\n\u2006 \u2006 \u2006 \u2006 std::cout << \"Item not found\" << std::endl;\n}\n\n3.Deleting items from the map:\n// Deleting an item from the map\n\nstd::string key_to_delete = \"key1\";\nA.erase(key_to_delete);\n\n4.Updating items in the map:\n// Updating an item in the map\n\nstd::string key_to_update = \"key3\";\nA[key_to_update] = \"new_value\";\n\n\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014 std::multimap<std::string, int>\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\n\nBelow are examples of using std::multimap to perform the operations you mentioned:\n\nInsert items:\n##include <iostream>\n##include <map>\n\nint main() {\n\u2006 \u2006 \u2006 \u2006 std::multimap<std::string, int> myMultimap;\n\n\u2006 \u2006 \u2006 \u2006 // Inserting elements into the multimap\n\n\u2006 \u2006 \u2006 \u2006 myMultimap.insert(std::make_pair(\"apple\", 10));\n\u2006 \u2006 \u2006 \u2006 myMultimap.insert(std::make_pair(\"orange\", 20));\n\u2006 \u2006 \u2006 \u2006 myMultimap.insert(std::make_pair(\"apple\", 30)); // Non-unique key\n\n\u2006 \u2006 \u2006 \u2006 // Iterating through the multimap to show the inserted items\n\u2006 \u2006 \u2006 \u2006 for (auto it = myMultimap.begin(); it != myMultimap.end(); ++it) {\n\u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 std::cout << it->first << \" => \" << it->second << std::endl;\n\u2006 \u2006 \u2006 \u2006 }\n\n\u2006 \u2006 \u2006 \u2006 return 0;\n}\n\n// to select all the items those have a same key:\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\n##include <iostream>\n##include <map>\n\nint main() {\n\u2006 \u2006 \u2006 \u2006 std::multimap<std::string, std::string> myMultiMap;\n\u2006 \u2006 \u2006 \u2006 \n\u2006 \u2006 \u2006 \u2006 // Insert some key-value pairs into the multimap\n\u2006 \u2006 \u2006 \u2006 myMultiMap.insert(std::make_pair(\"key1\", \"value1\"));\n\u2006 \u2006 \u2006 \u2006 myMultiMap.insert(std::make_pair(\"key2\", \"value2\"));\n\u2006 \u2006 \u2006 \u2006 myMultiMap.insert(std::make_pair(\"key1\", \"value3\"));\n\u2006 \u2006 \u2006 \u2006 myMultiMap.insert(std::make_pair(\"key3\", \"value4\"));\n\u2006 \u2006 \u2006 \u2006 \n\u2006 \u2006 \u2006 \u2006 // Select all the values associated with the key \"key1\"\n\u2006 \u2006 \u2006 \u2006 auto range = myMultiMap.equal_range(\"key1\");\n\u2006 \u2006 \u2006 \u2006 \n\u2006 \u2006 \u2006 \u2006 // Iterate over the range and print the values\n\u2006 \u2006 \u2006 \u2006 for (auto it = range.first; it != range.second; ++it) {\n\u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 std::cout << \"Key: \" << it->first << \", Value: \" << it->second << std::endl;\n\u2006 \u2006 \u2006 \u2006 }\n\u2006 \u2006 \u2006 \u2006 \n\u2006 \u2006 \u2006 \u2006 return 0;\n}\n\n//\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\n\nDelete items:\n// Deleting items with a specific key from the multimap\n\nauto range = myMultimap.equal_range(\"apple\");\nmyMultimap.erase(range.first, range.second);\n\nUpdate items:\n// Updating items with a specific key in the multimap\n\nauto range = myMultimap.equal_range(\"apple\");\nfor (auto it = range.first; it != range.second; ++it) {\n\u2006 \u2006 \u2006 \u2006 if (it->second == 10) {\n\u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 it->second = 50; // Updating the value\n\u2006 \u2006 \u2006 \u2006 }\n}\n//remove repeated items\nstd::vector<std::string> const_vec(vec.begin(), vec.end());\ntry{\n\u2006 \u2006 \u2006 \u2006 \u2006 \u2006 // Create a non-const copy of the vect\n\u2006 \u2006 \u2006 \u2006 \u2006 \u2006 // Sort the vector\n\u2006 \u2006 \u2006 \u2006 \u2006 \u2006 std::sort(const_vec.begin(), const_vec.end());\n\u2006 \u2006 \u2006 \u2006 \u2006 \u2006 // Use std::unique to remove adjacent duplicates\n\u2006 \u2006 \u2006 \u2006 \u2006 \u2006 auto it = std::unique(const_vec.begin(), const_vec.end());\n\u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 // Erase the elements after the unique ones\n\u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 const_vec.erase(it, const_vec.end());\n\u2006 \u2006 \u2006 \u2006 }\n\u2006 \u2006 \u2006 \u2006 catch(const std::exception& e){\n\u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 std::cerr << \"Error remove_repeated_items_vs: \" << e.what() << std::endl;\n\u2006 \u2006 \u2006 \u2006 }\n\u2006 \u2006 \u2006 \u2006 return const_vec;\nSearch items:\n// Searching for items with a specific key in the multimap\n\nauto range = myMultimap.equal_range(\"apple\");\nfor (auto it = range.first; it != range.second; ++it) {\n\u2006 \u2006 \u2006 \u2006 std::cout << \"Found: \" << it->first << \" => \" << it->second << std::endl;\n}\n\nThese examples demonstrate how to insert, delete, update, and search for items in a std::multimap.\n\n\nTo search a specific range:\n\n\u2006 \u2006 \u2006 \u2006 size_t jj = 0;\u2006 \u2006 // Assuming this is your index\n\u2006 \u2006 \u2006 \u2006 auto it_range_begin = std::next(str_get_other_rules.begin(), 200);\n\u2006 \u2006 \u2006 \u2006 auto it_range_end = std::next(str_get_other_rules.begin(), 300);\n\u2006 \u2006 \u2006 \u2006 auto it_jj = std::find_if(it_range_begin, it_range_end, [strsen_tok1, jj](const std::string& s) {\n\u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 return s == strsen_tok1[jj];\n\u2006 \u2006 \u2006 \u2006 });\n\u2006 \u2006 \u2006 \u2006 if (it_jj != it_range_end) {\n\u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 // Found the element within the specified range\n\u2006 \u2006 \u2006 \u2006 }\n\n\nWill search the items between 200-300\n\n\n\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\n\n##include <unordered_set>\n\nstd::vector<std::string> removeDuplicates(const std::vector<std::string>& inputVector) {\n\u2006 \u2006 \u2006 \u2006 std::unordered_set<std::string> uniqueElements;\n\u2006 \u2006 \u2006 \u2006 std::vector<std::string> result;\n\n\u2006 \u2006 \u2006 \u2006 for (const auto& element : inputVector) {\n\u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 if (uniqueElements.insert(element).second) {\u2006 \u2006 // Insert the element and check if it was inserted successfully\n\u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 result.push_back(element);\u2006 \u2006 // If the element was inserted successfully, add it to the result vector\n\u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 }\n\u2006 \u2006 \u2006 \u2006 }\n\n\u2006 \u2006 \u2006 \u2006 return result;\n}\n\n\n\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014 Use std::vector and std::pair \u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\n\n##include <iostream>\n##include <vector>\n##include <string>\n##include <algorithm>\n\nint main() {\n\u2006 \u2006 \u2006 \u2006 std::vector<std::pair<std::string, std::string>> data;\n\n\u2006 \u2006 \u2006 \u2006 // 1. Insert data\n\u2006 \u2006 \u2006 \u2006 data.push_back(std::make_pair(\"Hello\", \"World\"));\n\u2006 \u2006 \u2006 \u2006 data.push_back(std::make_pair(\"Hello\", \"Jack\"));\n\u2006 \u2006 \u2006 \u2006 data.push_back(std::make_pair(\"C++\", \"Programming\"));\n\n\u2006 \u2006 \u2006 \u2006 // 2. Delete data\n\u2006 \u2006 \u2006 \u2006 auto it = std::remove_if(data.begin(), data.end(), [](const std::pair<std::string, std::string>& pair) {\n\u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 return pair.first == \"Hello\" && pair.second == \"World\";\n\u2006 \u2006 \u2006 \u2006 });\n\u2006 \u2006 \u2006 \u2006 data.erase(it, data.end());\n\n\u2006 \u2006 \u2006 \u2006 // 3. Update data\n\u2006 \u2006 \u2006 \u2006 for (auto& pair : data) {\n\u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 if (pair.first == \"Hello\") {\n\u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 pair.second = \"John\";\n\u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 }\n\u2006 \u2006 \u2006 \u2006 }\n\n\u2006 \u2006 \u2006 \u2006 // 4. Select data with the same key\n\u2006 \u2006 \u2006 \u2006 std::string key = \"Hello\";\n\u2006 \u2006 \u2006 \u2006 for (const auto& pair : data) {\n\u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 if (pair.first == key) {\n\u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 std::cout << \"a: \" << pair.first << \", b: \" << pair.second << std::endl;\n\u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 }\n\u2006 \u2006 \u2006 \u2006 }\n\n\u2006 \u2006 \u2006 \u2006 return 0;\n}\n\n\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014 use std::pair<std::string, std::string>\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\n\n##include <iostream>\n##include <vector>\n##include <string>\n##include <algorithm>\n\nint main() {\n\u2006 \u2006 \u2006 \u2006 // Inserting items into a vector of pairs\n\u2006 \u2006 \u2006 \u2006 std::vector<std::pair<std::string, std::string>> pairs;\n\u2006 \u2006 \u2006 \u2006 pairs.push_back(std::make_pair(\"key1\", \"value1\"));\n\u2006 \u2006 \u2006 \u2006 pairs.push_back(std::make_pair(\"key2\", \"value2\"));\n\n\u2006 \u2006 \u2006 \u2006 // Updating items in the vector\n\u2006 \u2006 \u2006 \u2006 for (auto& pair : pairs) {\n\u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 if (pair.first == \"key1\") {\n\u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 pair.second = \"new value\";\n\u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 }\n\u2006 \u2006 \u2006 \u2006 }\n\n\u2006 \u2006 \u2006 \u2006 // Deleting items from the vector\n\u2006 \u2006 \u2006 \u2006 pairs.erase(std::remove_if(pairs.begin(), pairs.end(), [](const auto& pair) {\n\u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 return pair.first == \"key2\";\n\u2006 \u2006 \u2006 \u2006 }), pairs.end());\n\n\u2006 \u2006 \u2006 \u2006 // Searching for items in the vector\n\u2006 \u2006 \u2006 \u2006 std::string searchKey = \"key1\";\n\u2006 \u2006 \u2006 \u2006 auto it = std::find_if(pairs.begin(), pairs.end(), [&searchKey](const auto& pair) {\n\u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 return pair.first == searchKey;\n\u2006 \u2006 \u2006 \u2006 });\n\u2006 \u2006 \u2006 \u2006 if (it != pairs.end()) {\n\u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 std::cout << \"Found: \" << it->first << \" : \" << it->second << std::endl;\n\u2006 \u2006 \u2006 \u2006 } else {\n\u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 std::cout << \"Key not found: \" << searchKey << std::endl;\n\u2006 \u2006 \u2006 \u2006 }\n\n\u2006 \u2006 \u2006 \u2006 return 0;\n}\n\n\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014use std::map \u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\n\n##include <iostream>\n##include <string>\n##include <map>\n\nint main() {\n\u2006 \u2006 \u2006 \u2006 // Inserting items into a map of pairs\n\u2006 \u2006 \u2006 \u2006 std::map<std::string, std::string> myMap;\n\u2006 \u2006 \u2006 \u2006 myMap.insert(std::make_pair(\"key1\", \"value1\"));\n\u2006 \u2006 \u2006 \u2006 myMap.insert(std::make_pair(\"key2\", \"value2\"));\n\n\u2006 \u2006 \u2006 \u2006 // Updating items in the map\n\u2006 \u2006 \u2006 \u2006 myMap[\"key1\"] = \"new value\";\u2006 \u2006 // Update the value associated with key1\n\n\u2006 \u2006 \u2006 \u2006 // Deleting items from the map\n\u2006 \u2006 \u2006 \u2006 myMap.erase(\"key2\");\u2006 \u2006 // Delete the item with key2\n\n\u2006 \u2006 \u2006 \u2006 // Searching for items in the map\n\u2006 \u2006 \u2006 \u2006 std::string searchKey = \"key1\";\n\u2006 \u2006 \u2006 \u2006 auto it = myMap.find(searchKey);\n\u2006 \u2006 \u2006 \u2006 if (it != myMap.end()) {\n\u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 std::cout << \"Found: \" << it->first << \" : \" << it->second << std::endl;\n\u2006 \u2006 \u2006 \u2006 } else {\n\u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 std::cout << \"Key not found: \" << searchKey << std::endl;\n\u2006 \u2006 \u2006 \u2006 }\n\n\u2006 \u2006 \u2006 \u2006 return 0;\n}\n\n\u2014\u2014\u2014\u2014\u2014\u2014\u2014 insert NON Repeated data into a dataset \u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\n\n/*\n\tremove repeated items in rr.name\n*/\nstd::unordered_set<std::string> unique_names(rr.names.begin(), rr.names.end());\nfor (const auto& name : rr.names) {\n\tif (unique_names.find(name) == unique_names.end()) {\n\t\trr.names.push_back(name);\n\t\tunique_names.insert(name);\n\t}\n}\nrr.names.clear();\nrr.names.insert(rr.names.end(),unique_names.begin(),unique_names.end());\n\n\u2014 Or --\n\nstd::vector<std::string> const_vec(vec.begin(), vec.end());\ntry{\n\u2006 \u2006 \u2006 \u2006 \u2006 \u2006 // Create a non-const copy of the vect\n\u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 // Sort the vector\n\u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 std::sort(const_vec.begin(), const_vec.end());\n\u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 // Use std::unique to remove adjacent duplicates\n\u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 auto it = std::unique(const_vec.begin(), const_vec.end());\n\u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 // Erase the elements after the unique ones\n\u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 const_vec.erase(it, const_vec.end());\n\u2006 \u2006 \u2006 \u2006 }\n\u2006 \u2006 \u2006 \u2006 catch(const std::exception& e){\n\u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 std::cerr << \"Function:remove_repeated_items_vsError(line:339): \" << e.what() << std::endl;\n\u2006 \u2006 \u2006 \u2006 }\n\u2006 \u2006 \u2006 \u2006 return const_vec;\n\n\u2014\u2014\u2014\u2014 remove empty items \u2014\u2014\u2014\u2014\u2014\u2014\u2014\n// Use the erase-remove idiom to remove empty items\n\u2006 \u2006 \u2006 \u2006 vec.erase(std::remove(vec.begin(), vec.end(), \"\"), vec.end());\n\n\n\u2014\u2014\u2014 sore in multiple thread\u2014\u2014\u2014\u2014\n\nstd::sort(std::execution::par_unseq, x.begin(), x.end())\n\n##include <iostream>\n##include <vector>\n##include <algorithm>\n##include <execution>\u2006 \u2006 // for parallel execution policies (C++17)\n\nint main() {\n\u2006 \u2006 \u2006 \u2006 // Create a vector of integers\n\u2006 \u2006 \u2006 \u2006 std::vector<int> x = {5, 2, 8, 1, 7, 3, 9, 4, 6};\n\n\u2006 \u2006 \u2006 \u2006 // Sort the vector in parallel using std::execution::par_unseq\n\u2006 \u2006 \u2006 \u2006 std::sort(std::execution::par_unseq, x.begin(), x.end());\n\n\u2006 \u2006 \u2006 \u2006 // Print the sorted vector\n\u2006 \u2006 \u2006 \u2006 for (const auto& elem : x) {\n\u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 std::cout << elem << \" \";\n\u2006 \u2006 \u2006 \u2006 }\n\u2006 \u2006 \u2006 \u2006 std::cout << std::endl;\n\n\u2006 \u2006 \u2006 \u2006 return 0;\n}\n\n\u2014 can use std::execution::par_unseq in c++ standard library \u2014\u2014\u2014\n\nstd::for_each:\n\n##include <iostream>\n##include <vector>\n##include <algorithm>\n##include <execution>\u2006 \u2006 // for parallel execution policies (C++17)\n\nint main() {\n\u2006 \u2006 \u2006 \u2006 std::vector<int> numbers = {1, 2, 3, 4, 5};\n\n\u2006 \u2006 \u2006 \u2006 // Use std::for_each with std::execution::par_unseq\n\u2006 \u2006 \u2006 \u2006 std::for_each(std::execution::par_unseq, numbers.begin(), numbers.end(), [](int& num) {\n\u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 num *= 2;\n\u2006 \u2006 \u2006 \u2006 });\n\n\u2006 \u2006 \u2006 \u2006 // Print the modified vector\n\u2006 \u2006 \u2006 \u2006 for (const auto& num : numbers) {\n\u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 std::cout << num << \" \";\n\u2006 \u2006 \u2006 \u2006 }\n\u2006 \u2006 \u2006 \u2006 std::cout << std::endl;\n\n\u2006 \u2006 \u2006 \u2006 return 0;\n}\n\nstd::transform:\n\n##include <iostream>\n##include <vector>\n##include <algorithm>\n##include <execution>\u2006 \u2006 // for parallel execution policies (C++17)\n\nint main() {\n\u2006 \u2006 \u2006 \u2006 std::vector<int> input = {1, 2, 3, 4, 5};\n\u2006 \u2006 \u2006 \u2006 std::vector<int> output(input.size());\n\n\u2006 \u2006 \u2006 \u2006 // Use std::transform with std::execution::par_unseq\n\u2006 \u2006 \u2006 \u2006 std::transform(std::execution::par_unseq, input.begin(), input.end(), output.begin(), [](int num) {\n\u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 return num * 2;\n\u2006 \u2006 \u2006 \u2006 });\n\n\u2006 \u2006 \u2006 \u2006 // Print the transformed vector\n\u2006 \u2006 \u2006 \u2006 for (const auto& num : output) {\n\u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 std::cout << num << \" \";\n\u2006 \u2006 \u2006 \u2006 }\n\u2006 \u2006 \u2006 \u2006 std::cout << std::endl;\n\n\u2006 \u2006 \u2006 \u2006 return 0;\n}\n\nstd::reduce:\n\n##include <iostream>\n##include <vector>\n##include <numeric>\n##include <execution>\u2006 \u2006 // for parallel execution policies (C++17)\n\nint main() {\n\u2006 \u2006 \u2006 \u2006 std::vector<int> numbers = {1, 2, 3, 4, 5};\n\n\u2006 \u2006 \u2006 \u2006 // Use std::reduce with std::execution::par_unseq to sum the elements\n\u2006 \u2006 \u2006 \u2006 int sum = std::reduce(std::execution::par_unseq, numbers.begin(), numbers.end());\n\n\u2006 \u2006 \u2006 \u2006 std::cout << \"Sum of elements: \" << sum << std::endl;\n\n\u2006 \u2006 \u2006 \u2006 return 0;\n}\n\nstd::count:\n\n##include <iostream>\n##include <vector>\n##include <algorithm>\n##include <execution>\u2006 \u2006 // for parallel execution policies (C++17)\n\nint main() {\n\u2006 \u2006 \u2006 \u2006 std::vector<int> numbers = {1, 2, 3, 4, 5, 3, 2, 3};\n\n\u2006 \u2006 \u2006 \u2006 // Use std::count with std::execution::par_unseq to count occurrences of 3\n\u2006 \u2006 \u2006 \u2006 int count = std::count(std::execution::par_unseq, numbers.begin(), numbers.end(), 3);\n\n\u2006 \u2006 \u2006 \u2006 std::cout << \"Count of 3: \" << count << std::endl;\n\n\u2006 \u2006 \u2006 \u2006 return 0;\n}\n\nstd::find:\n\n##include <iostream>\n##include <vector>\n##include <algorithm>\n##include <execution>\u2006 \u2006 // for parallel execution policies (C++17)\n\nint main() {\n\u2006 \u2006 \u2006 \u2006 std::vector<int> numbers = {1, 2, 3, 4, 5};\n\n\u2006 \u2006 \u2006 \u2006 // Use std::find with std::execution::par_unseq to find the value 3\n\u2006 \u2006 \u2006 \u2006 auto it = std::find(std::execution::par_unseq, numbers.begin(), numbers.end(), 3);\n\n\u2006 \u2006 \u2006 \u2006 if (it != numbers.end()) {\n\u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 std::cout << \"Value 3 found at index: \" << std::distance(numbers.begin(), it) << std::endl;\n\u2006 \u2006 \u2006 \u2006 } else {\n\u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 std::cout << \"Value 3 not found\" << std::endl;\n\u2006 \u2006 \u2006 \u2006 }\n\n\u2006 \u2006 \u2006 \u2006 return 0;\n}\n\n\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\n\n##include <iostream>\n##include <vector>\n##include <algorithm>\n##include <execution>\u2006 \u2006 // for parallel execution policies (C++17)\n##include <string>\n\nint main() {\n\u2006 \u2006 \u2006 \u2006 std::vector<std::string> words = {\"apple\", \"banana\", \"orange\", \"grape\", \"melon\"};\n\n\u2006 \u2006 \u2006 \u2006 // String to search for\n\u2006 \u2006 \u2006 \u2006 std::string target = \"orange\";\n\n\u2006 \u2006 \u2006 \u2006 // Use std::find with std::execution::par_unseq to search for the string\n\u2006 \u2006 \u2006 \u2006 auto it = std::find(std::execution::par_unseq, words.begin(), words.end(), target);\n\n\u2006 \u2006 \u2006 \u2006 if (it != words.end()) {\n\u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 std::cout << \"String found: \" << target << std::endl;\n\u2006 \u2006 \u2006 \u2006 } else {\n\u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 std::cout << \"String not found: \" << target << std::endl;\n\u2006 \u2006 \u2006 \u2006 }\n\n\u2006 \u2006 \u2006 \u2006 return 0;\n}\n\nThese examples demonstrate the use of various algorithms from the C++ standard library with the std::execution::par_unseq execution policy, enabling potential parallel execution and vectorization where applicable.\n\n\n\u2014\u2014\u2014\u2014\u2014\u2014\nWith different datatype:\n\nSupposed I defined struct Mdatatype {std::string name; std::string address;};\nNow i want to put std::vector<Mdatatype>persons_names\npersons_names.erase(std::remove(persons_names.begin(), persons_names.end(), gn), persons_names.end());\n\nI want to remove the items which name contains \"Jack\" , how to do that?\nTo remove items from a std::vector<Mdatatype> where the name member contains \"Jack\", you can use the std::remove_if algorithm with a lambda function as the predicate. Here's an example:\n\n##include <iostream>\n##include <vector>\n##include <algorithm>\n##include <string>\n\nstruct Mdatatype {\n\u2006 \u2006 \u2006 \u2006 std::string name;\n\u2006 \u2006 \u2006 \u2006 std::string address;\n};\n\nint main() {\n\u2006 \u2006 \u2006 \u2006 std::vector<Mdatatype> persons_names = {\n\u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 {\"Jack Johnson\", \"123 Main St\"},\n\u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 {\"Alice Smith\", \"456 Elm St\"},\n\u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 {\"Jack Black\", \"789 Oak St\"}\n\u2006 \u2006 \u2006 \u2006 };\n\n\u2006 \u2006 \u2006 \u2006 auto removePredicate = [](const Mdatatype& person) {\n\u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 return person.name.find(\"Jack\") != std::string::npos;\n\u2006 \u2006 \u2006 \u2006 };\n\n\u2006 \u2006 \u2006 \u2006 persons_names.erase(std::remove_if(persons_names.begin(), persons_names.end(), removePredicate), persons_names.end());\n\n\u2006 \u2006 \u2006 \u2006 for (const auto& person : persons_names) {\n\u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 std::cout << \"Name: \" << person.name << \", Address: \" << person.address << std::endl;\n\u2006 \u2006 \u2006 \u2006 }\n\n\u2006 \u2006 \u2006 \u2006 return 0;\n}\nIn this code snippet, we define a lambda function removePredicate that checks if the name member of a Mdatatype struct contains the substring \"Jack\". We then use std::remove_if to move all elements that match the predicate to the end of the vector and erase to remove those elements.\n\nAfter the removal operation, we iterate over the vector and print out the remaining elements. The output will show only the items where the name does not contain \"Jack\".\n\nWill item {\"Jack\", \"555, Main str\"} be found using the above method?\nIn the code provided, the removePredicate lambda function checks if the name member of a Mdatatype struct contains the substring \"Jack\" using the find function. This means that it will match any name that contains \"Jack\" as a substring, not just the exact string \"Jack\".\n\nSo, if you have an item with the name \"Jack\" (e.g., {\"Jack\", \"555 Main St\"}), it will be found and removed by the remove_if algorithm because \"Jack\" is a substring of the name \"Jack\".\n\nHere is an example to demonstrate this:\n\n##include <iostream>\n##include <vector>\n##include <algorithm>\n##include <string>\n\nstruct Mdatatype {\n\u2006 \u2006 \u2006 \u2006 std::string name;\n\u2006 \u2006 \u2006 \u2006 std::string address;\n};\n\nint main() {\n\u2006 \u2006 \u2006 \u2006 std::vector<Mdatatype> persons_names = {\n\u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 {\"Jack Johnson\", \"123 Main St\"},\n\u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 {\"Alice Smith\", \"456 Elm St\"},\n\u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 {\"Jack\", \"555 Main St\"}\n\u2006 \u2006 \u2006 \u2006 };\n\n\u2006 \u2006 \u2006 \u2006 auto removePredicate = [](const Mdatatype& person) {\n\u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 return person.name.find(\"Jack\") != std::string::npos;\n\u2006 \u2006 \u2006 \u2006 };\n\n\u2006 \u2006 \u2006 \u2006 persons_names.erase(std::remove_if(persons_names.begin(), persons_names.end(), removePredicate), persons_names.end());\n\n\u2006 \u2006 \u2006 \u2006 for (const auto& person : persons_names) {\n\u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 std::cout << \"Name: \" << person.name << \", Address: \" << person.address << std::endl;\n\u2006 \u2006 \u2006 \u2006 }\n\n\u2006 \u2006 \u2006 \u2006 return 0;\n}\nIn this example, the item with the name \"Jack\" will be found and removed from the persons_names vector because \"Jack\" is a substring of the name.\n\nI need to remove the exact item equal to \"Jack\", how to do that?\nTo remove an item from a std::vector<Mdatatype> where the name member is exactly equal to \"Jack\" (not just a substring), you can modify the lambda function used as the predicate for std::remove_if. Here's how you can achieve this:\n\n##include <iostream>\n##include <vector>\n##include <algorithm>\n##include <string>\n\nstruct Mdatatype {\n\u2006 \u2006 \u2006 \u2006 std::string name;\n\u2006 \u2006 \u2006 \u2006 std::string address;\n};\n\nint main() {\n\u2006 \u2006 \u2006 \u2006 std::vector<Mdatatype> persons_names = {\n\u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 {\"Jack Johnson\", \"123 Main St\"},\n\u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 {\"Alice Smith\", \"456 Elm St\"},\n\u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 {\"Jack\", \"555 Main St\"}\n\u2006 \u2006 \u2006 \u2006 };\n\n\u2006 \u2006 \u2006 \u2006 std::string nameToRemove = \"Jack\";\n\n\u2006 \u2006 \u2006 \u2006 persons_names.erase(std::remove_if(persons_names.begin(), persons_names.end(), \n\u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 [nameToRemove](const Mdatatype& person) {\n\u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 return person.name == nameToRemove;\n\u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 }), persons_names.end());\n\n\u2006 \u2006 \u2006 \u2006 for (const auto& person : persons_names) {\n\u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 std::cout << \"Name: \" << person.name << \", Address: \" << person.address << std::endl;\n\u2006 \u2006 \u2006 \u2006 }\n\n\u2006 \u2006 \u2006 \u2006 return 0;\n}\nIn this code snippet, we define a lambda function as the predicate for std::remove_if. The lambda function captures the nameToRemove variable, which is set to the exact name you want to remove (\"Jack\" in this case). The lambda function checks if the name member of the Mdatatype struct is equal to nameToRemove using the equality operator ==.\n\nBy comparing the name member with the exact name to remove, only items with the exact name \"Jack\" will be removed from the persons_names vector.\n\n@\nfor(auto it = persons_names.begin(); it != persons_names.end(); ){\n\u2006 \u2006 \u2006 \u2006 if (*it == \"Jack\"){\n\u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 it = persons_names.erase(it);\n\u2006 \u2006 \u2006 \u2006 } else {\n\u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 ++it;\n\u2006 \u2006 \u2006 \u2006 }\n}\n\n\nExcluse repeated items :\n\nstd::set<std::string> unique_words(word_index_adv.begin(), word_index_adv.end());\nword_data_adv.insert(word_data_adv.end(), unique_words.begin(), unique_words.end());\n"
        },
        {
            "x": 485,
            "y": 184,
            "height": 740,
            "width": 901,
            "color": "yellow",
            "title": "",
            "text": "Std::wstring / std::string converter\n\n##include <codecvt>\n##include <cstdint>\n##include <iostream>\n##include <locale>\n##include <string>\n\nint main()\n{\n\u2006 \u2006 \u2006 \u2006 // UTF-8 data. The character U+1d10b, musical sign segno, does not fit in UCS-2\n\u2006 \u2006 \u2006 \u2006 std::string utf8 = \"z\\u6c34\\U0001d10b\";\n\n\u2006 \u2006 \u2006 \u2006 // the UTF-8 / UTF-16 standard conversion facet\n\u2006 \u2006 \u2006 \u2006 std::wstring_convert<std::codecvt_utf8_utf16<char16_t>, char16_t> utf16conv;\n\u2006 \u2006 \u2006 \u2006 std::u16string utf16 = utf16conv.from_bytes(utf8);\n\u2006 \u2006 \u2006 \u2006 std::cout << \"UTF-16 conversion produced \" << utf16.size() << \" code units:\\n\"\n\u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 << std::showbase << std::hex;\n\u2006 \u2006 \u2006 \u2006 for (char16_t c : utf16)\n\u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 std::cout << static_cast<std::uint16_t>(c) << ' ';\n\n\u2006 \u2006 \u2006 \u2006 // the UTF-8 / UCS-2 standard conversion facet\n\u2006 \u2006 \u2006 \u2006 std::wstring_convert<std::codecvt_utf8<char16_t>, char16_t> ucs2conv;\n\u2006 \u2006 \u2006 \u2006 try\n\u2006 \u2006 \u2006 \u2006 {\n\u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 std::u16string ucs2 = ucs2conv.from_bytes(utf8);\n\u2006 \u2006 \u2006 \u2006 }\n\u2006 \u2006 \u2006 \u2006 catch(const std::range_error& e)\n\u2006 \u2006 \u2006 \u2006 {\n\u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 std::u16string ucs2 = ucs2conv.from_bytes(utf8.substr(0, ucs2conv.converted()));\n\u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 std::cout << \"\\nUCS-2 failed after producing \" << std::dec << ucs2.size()\n\u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 << \" characters:\\n\" << std::showbase << std::hex;\n\u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 for (char16_t c : ucs2)\n\u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 std::cout << static_cast<std::uint16_t>(c) << ' ';\n\u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 \u2006 std::cout << '\\n';\n\u2006 \u2006 \u2006 \u2006 }\n}"
        },
        {
            "x": 410,
            "y": 304,
            "height": 360,
            "width": 852,
            "color": "yellow",
            "title": "",
            "text": "Unlock a folder on linux:\n\n$ sudo chown your_username filename\n$ chmod u+rw filename\n\nUnlock a folder\n$ sudo chown your_username foldername\n\nGive the user read and write permission to the folder:\n$ chmod u+rw foldername\nOr\nchmod 600 foldername\n\n\n\n\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\n\nLock a file:\n$ chmod u-w filename\n$ sudo chown root filename"
        },
        {
            "x": 554,
            "y": 736,
            "height": 429,
            "width": 784,
            "color": "yellow",
            "title": "",
            "text": "/** how to compile and install g++ **/\n\nsudo apt-get install libgmp-dev libmpfr-dev libmpc-dev\n\n1.git clone https://github.com/gcc-mirror/gcc.git\n2.\ncd gcc\n./configure --prefix=/usr/local/gcc-13.3.0 --enable-languages=c,c++,fortran --disable-multilib\nor:\n./configure --host=x86_64-pc-linux-gnu\n3.\nmake -j4\n4.\nmake install\n5.\nexport PATH=/usr/local/gcc-13.3.0/bin:$PATH\n6.\n/gcc-13.3.0/bin/gcc --version\n\n7. Install :\nsudo apt-get install g++-multilib\nsudo apt install build-essential\n\n\n\n\n"
        },
        {
            "x": 684,
            "y": 659,
            "height": 150,
            "width": 942,
            "color": "yellow",
            "title": "",
            "text": "Return the max int -> std::pair<std::string,std::string> dataset\n\nstd::unordered_multiplemap<int,std::pair<std::string,std::string>> res;\n\nauto maxIt = std::max_element(res.begin(), res.end(),\n        [](const auto& lhs, const auto& rhs) { return lhs.first < rhs.first; });\n    std::pair<std::string,std::string> f_res = maxIt->second;\n"
        },
        {
            "x": 602,
            "y": 644,
            "height": 603,
            "width": 778,
            "color": "yellow",
            "title": "",
            "text": "Call back functions:\n\n##include <cmath>\n##include <numbers>\n\ndouble gelu(double x) {\n    double sqrt2_over_pi = std::sqrt(2.0 / std::numbers::pi_v<double>);\n    return 0.5 * x * (1 + std::tanh(sqrt2_over_pi * (x + 0.044715 * std::pow(x, 3))));\n}\n\n-----------------------------------------------------------------------------------------------------------\n\n##include <numeric>\n##include <algorithm>\n##include <utility>\n\ntemplate <std::size_t Axis, typename T>\nauto softmax(const std::vector<T>& input) {\n    std::vector<T> output(input.size());\n    std::partial_sum(input.begin(), input.end(), output.begin());\n\n    T max_val = *std::max_element(input.begin(), input.end());\n    for (auto& elem : input) {\n        elem -= max_val;\n    }\n\n    for (auto& elem : input) {\n        elem = std::exp(elem);\n    }\n\n    T sum = std::accumulate(input.begin(), input.end(), 0.0);\n    for (auto& elem : input) {\n        elem /= sum;\n    }\n\n    return input;\n}"
        },
        {
            "x": 1139,
            "y": 166,
            "height": 664,
            "width": 917,
            "color": "yellow",
            "title": "",
            "text": "//Check the relations in paras\n\nstd::unordered_multimap<std::string,std::pair<std::string,std::string>> ttl::get_content_by_para(const std::string& sii) {\n    Jsonlib jsl_j;\n    std::unordered_multimap<std::string,std::pair<std::string,std::string>> str_book;\n    std::vector<std::string> pp = this->split_paragraphs(sii);\n    std::string next_paragraph_first_word; // new variable to store the first word of the next paragraph\n    for (const auto& item : pp) {\n        std::string para = item;\n        std::string pun_item = this->removeEnglishPunctuation_training(item);\n        jsl_j.toLower(pun_item);\n        std::string ttop = this->get_topics_root(pun_item);\n        if (!ttop.empty()) {\n            std::vector<std::string> tok_line = this->tokenize_en(para);\n            for(int i = 0; i < tok_line.size(); i++){\n                if(i + 1 < tok_line.size()){\n                    str_book.insert({ttop,std::make_pair(tok_line[i],tok_line[i+1])});\n                    std::cout << tok_line[i] << \" \" << tok_line[i+1] << '\\n';\n                }\n            }\n        }\n    }\n    return str_book;\n}\n\n"
        },
        {
            "x": 558,
            "y": 184,
            "height": 115,
            "width": 476,
            "color": "yellow",
            "title": "",
            "text": "English words\n\n#tag:link:https://touchtypie.github.io/english-words/#tag:link:\n\nhttp://gwicks.net/dictionaries.htm"
        },
        {
            "x": 939,
            "y": 517,
            "height": 798,
            "width": 991,
            "color": "yellow",
            "title": "",
            "text": "#tag:link:https://varieng.helsinki.fi/CoRD/corpora/BASE/#tag:link:\n#tag:link:https://ota.bodleian.ox.ac.uk/repository/xmlui/#tag:link:\n\n\nUCREL CLAWS7 Tagset\n\nAPPGE\tpossessive pronoun, pre-nominal (e.g. my, your, our)\nAT\tarticle (e.g. the, no)\nAT1\tsingular article (e.g. a, an, every)\nBCL\tbefore-clause marker (e.g. in order (that),in order (to))\nCC\tcoordinating conjunction (e.g. and, or)\nCCB\tadversative coordinating conjunction ( but)\nCS\tsubordinating conjunction (e.g. if, because, unless, so, for)\nCSA\tas (as conjunction)\nCSN\tthan (as conjunction)\nCST\tthat (as conjunction)\nCSW\twhether (as conjunction)\nDA\tafter-determiner or post-determiner capable of pronominal function (e.g. such, former, same)\nDA1\tsingular after-determiner (e.g. little, much)\nDA2\tplural after-determiner (e.g. few, several, many)\nDAR\tcomparative after-determiner (e.g. more, less, fewer)\nDAT\tsuperlative after-determiner (e.g. most, least, fewest)\nDB\tbefore determiner or pre-determiner capable of pronominal function (all, half)\nDB2\tplural before-determiner ( both)\nDD\tdeterminer (capable of pronominal function) (e.g any, some)\nDD1\tsingular determiner (e.g. this, that, another)\nDD2\tplural determiner ( these,those)\nDDQ\twh-determiner (which, what)\nDDQGE\twh-determiner, genitive (whose)\nDDQV\twh-ever determiner, (whichever, whatever)\nEX\texistential there\nFO\tformula\nFU\tunclassified word\nFW\tforeign word\nGE\tgermanic genitive marker - (' or's)\nIF\tfor (as preposition)\nII\tgeneral preposition\nIO\tof (as preposition)\nIW\twith, without (as prepositions)\nJJ\tgeneral adjective\nJJR\tgeneral comparative adjective (e.g. older, better, stronger)\nJJT\tgeneral superlative adjective (e.g. oldest, best, strongest)\nJK\tcatenative adjective (able in be able to, willing in be willing to)\nMC\tcardinal number,neutral for number (two, three..)\nMC1\tsingular cardinal number (one)\nMC2\tplural cardinal number (e.g. sixes, sevens)\nMCGE\tgenitive cardinal number, neutral for number (two's, 100's)\nMCMC\thyphenated number (40-50, 1770-1827)\nMD\tordinal number (e.g. first, second, next, last)\nMF\tfraction,neutral for number (e.g. quarters, two-thirds)\nND1\tsingular noun of direction (e.g. north, southeast)\nNN\tcommon noun, neutral for number (e.g. sheep, cod, headquarters)\nNN1\tsingular common noun (e.g. book, girl)\nNN2\tplural common noun (e.g. books, girls)\nNNA\tfollowing noun of title (e.g. M.A.)\nNNB\tpreceding noun of title (e.g. Mr., Prof.)\nNNL1\tsingular locative noun (e.g. Island, Street)\nNNL2\tplural locative noun (e.g. Islands, Streets)\nNNO\tnumeral noun, neutral for number (e.g. dozen, hundred)\nNNO2\tnumeral noun, plural (e.g. hundreds, thousands)\nNNT1\ttemporal noun, singular (e.g. day, week, year)\nNNT2\ttemporal noun, plural (e.g. days, weeks, years)\nNNU\tunit of measurement, neutral for number (e.g. in, cc)\nNNU1\tsingular unit of measurement (e.g. inch, centimetre)\nNNU2\tplural unit of measurement (e.g. ins., feet)\nNP\tproper noun, neutral for number (e.g. IBM, Andes)\nNP1\tsingular proper noun (e.g. London, Jane, Frederick)\nNP2\tplural proper noun (e.g. Browns, Reagans, Koreas)\nNPD1\tsingular weekday noun (e.g. Sunday)\nNPD2\tplural weekday noun (e.g. Sundays)\nNPM1\tsingular month noun (e.g. October)\nNPM2\tplural month noun (e.g. Octobers)\nPN\tindefinite pronoun, neutral for number (none)\nPN1\tindefinite pronoun, singular (e.g. anyone, everything, nobody, one)\nPNQO\tobjective wh-pronoun (whom)\nPNQS\tsubjective wh-pronoun (who)\nPNQV\twh-ever pronoun (whoever)\nPNX1\treflexive indefinite pronoun (oneself)\nPPGE\tnominal possessive personal pronoun (e.g. mine, yours)\nPPH1\t3rd person sing. neuter personal pronoun (it)\nPPHO1\t3rd person sing. objective personal pronoun (him, her)\nPPHO2\t3rd person plural objective personal pronoun (them)\nPPHS1\t3rd person sing. subjective personal pronoun (he, she)\nPPHS2\t3rd person plural subjective personal pronoun (they)\nPPIO1\t1st person sing. objective personal pronoun (me)\nPPIO2\t1st person plural objective personal pronoun (us)\nPPIS1\t1st person sing. subjective personal pronoun (I)\nPPIS2\t1st person plural subjective personal pronoun (we)\nPPX1\tsingular reflexive personal pronoun (e.g. yourself, itself)\nPPX2\tplural reflexive personal pronoun (e.g. yourselves, themselves)\nPPY\t2nd person personal pronoun (you)\nRA\tadverb, after nominal head (e.g. else, galore)\nREX\tadverb introducing appositional constructions (namely, e.g.)\nRG\tdegree adverb (very, so, too)\nRGQ\twh- degree adverb (how)\nRGQV\twh-ever degree adverb (however)\nRGR\tcomparative degree adverb (more, less)\nRGT\tsuperlative degree adverb (most, least)\nRL\tlocative adverb (e.g. alongside, forward)\nRP\tprep. adverb, particle (e.g about, in)\nRPK\tprep. adv., catenative (about in be about to)\nRR\tgeneral adverb\nRRQ\twh- general adverb (where, when, why, how)\nRRQV\twh-ever general adverb (wherever, whenever)\nRRR\tcomparative general adverb (e.g. better, longer)\nRRT\tsuperlative general adverb (e.g. best, longest)\nRT\tquasi-nominal adverb of time (e.g. now, tomorrow)\nTO\tinfinitive marker (to)\nUH\tinterjection (e.g. oh, yes, um)\nVB0\tbe, base form (finite i.e. imperative, subjunctive)\nVBDR\twere\nVBDZ\twas\nVBG\tbeing\nVBI\tbe, infinitive (To be or not... It will be ..)\nVBM\tam\nVBN\tbeen\nVBR\tare\nVBZ\tis\nVD0\tdo, base form (finite)\nVDD\tdid\nVDG\tdoing\nVDI\tdo, infinitive (I may do... To do...)\nVDN\tdone\nVDZ\tdoes\nVH0\thave, base form (finite)\nVHD\thad (past tense)\nVHG\thaving\nVHI\thave, infinitive\nVHN\thad (past participle)\nVHZ\thas\nVM\tmodal auxiliary (can, will, would, etc.)\nVMK\tmodal catenative (ought, used)\nVV0\tbase form of lexical verb (e.g. give, work)\nVVD\tpast tense of lexical verb (e.g. gave, worked)\nVVG\t-ing participle of lexical verb (e.g. giving, working)\nVVGK\t-ing participle catenative (going in be going to)\nVVI\tinfinitive (e.g. to give... It will work...)\nVVN\tpast participle of lexical verb (e.g. given, worked)\nVVNK\tpast participle catenative (e.g. bound in be bound to)\nVVZ\t-s form of lexical verb (e.g. gives, works)\nXX\tnot, n't\nZZ1\tsingular letter of the alphabet (e.g. A,b)\nZZ2\tplural letter of the alphabet (e.g. A's, b's)\nNOTE: \"DITTO TAGS\"\nAny of the tags listed above may in theory be modified by the addition of a pair of numbers to it: eg. DD21, DD22 This signifies that the tag occurs as part of a sequence of similar tags, representing a sequence of words which for grammatical purposes are treated as a single unit. For example the expression in terms of is treated as a single preposition, receiving the tags:\n\t\t in_II31 terms_II32 of_II33 \nThe first of the two digits indicates the number of words/tags in the sequence, and the second digit the position of each word within that sequence.\nSuch ditto tags are not included in the lexicon, but are assigned automatically by a program called IDIOMTAG which looks for a range of multi-word sequences included in the idiomlist. The following sample entries from the idiomlist show that syntactic ambiguity is taken into account, and also that, depending on the context, ditto tags may or may not be required for a particular word sequence:\n\n\t\tat_RR21 length_RR22\n\t\ta_DD21/RR21 lot_DD22/RR22\n\t\tin_CS21/II that_CS22/DD1 "
        },
        {
            "x": 40,
            "y": 40,
            "height": 75,
            "width": 164,
            "color": "yellow",
            "title": "",
            "text": "#tag:larger:^~&#tag:larger:"
        },
        {
            "x": 1091,
            "y": 617,
            "height": 341,
            "width": 414,
            "color": "yellow",
            "title": "",
            "text": "sudo ufw default deny\nsudo ufw default deny incoming\nsudo ufw default deny outgoing\nsudo ufw allow out 443\nsudo ufw allow out 53\nsudo ufw allow out 80\nsudo ufw reload\nsudo ufw status \n"
        },
        {
            "x": 60,
            "y": 60,
            "height": 1181,
            "width": 1263,
            "color": "yellow",
            "title": "",
            "text": "bool containsOnlyOneWord(const std::string& str) {\n    if(str.find(' ') != std::string::npos){\n        return false;//has space,there are more than one words\n\t}\n    else{\n        return true;\n\t}\n}\nvoid m_reading(const std::string& f_name){  \n    if(f_name.empty()){\n        return;\n    }\n    Jsonlib jsl_j;\n    nemslib nem_j;\n    std::vector<std::string> strBooks;\n    std::vector<std::string> strBooks_path;   \n    for (const auto& entry : std::filesystem::directory_iterator(f_name)) {\n        if (entry.is_regular_file() && entry.path().extension() == \".txt\") {\n            strBooks_path.push_back(entry.path());\n        }\n    }\n    /*\n        test\n    */\n    if(!strBooks_path.empty()){\n        std::vector<std::pair<std::string,std::string>> phrases_picked;\n        for(const auto& stb : strBooks_path){\n            std::string s_book_path = stb;\n            for(const auto& spath : strBooks_path){\n                if(stb != spath){\n                    std::ifstream file(spath);\n                    if(!file.is_open()){\n                        continue;\n                    }\n                    std::string line;\n                    std::string s_book;\n                    while(std::getline(file,line)){\n                        s_book += line + \" \";\n                        //std::this_thread::sleep_for(std::chrono::milliseconds(5));//seconds\n                    }\n                    file.close();\n                    s_book.pop_back();\n                    std::vector<std::string> split_byS = jsl_j.split_sentences(s_book);\n                    if(!split_byS.empty()){\n                        for(const auto& sen : split_byS){\n                            std::vector<std::string> tok_sens;\n                            std::string str_sen = sen;\n                            //str_sen = nem_j.removeEnglishPunctuation_training(str_sen);\n                            str_sen.erase(std::remove_if(str_sen.begin(), str_sen.end(),[](char c) { return std::ispunct(static_cast<unsigned char>(c)); }), str_sen.end());\n                            boost::algorithm::to_lower(str_sen);\n                            boost::algorithm::split(tok_sens, str_sen, boost::algorithm::is_space(), boost::algorithm::token_compress_off);\n                            if(!tok_sens.empty()){\n                                for(size_t i = 0; i < tok_sens.size(); ++i){\n                                    std::string s_combo;\n                                    for(size_t j = i; j < tok_sens.size(); ++j){\n                                        s_combo += tok_sens[j] + \" \";\n                                        std::string s_addd = s_combo;\n                                        s_addd.pop_back();\n                                        if(containsOnlyOneWord(s_addd)==false){\n                                            for(const auto& sks : strBooks_path){\n                                                if(sks != stb){\n                                                    std::string o_book_path = sks;\n                                                    std::string line_input;\n                                                    std::string str_other_book;\n                                                    std::ifstream obookfile(o_book_path);\n                                                    if(!obookfile.is_open()){\n                                                        continue;\n                                                    }\n                                                    std::cout << \"loading the others...\" << '\\n';\n                                                    while(std::getline(obookfile,line_input)){\n                                                        str_other_book += line_input + \" \";\n                                                        std::this_thread::sleep_for(std::chrono::milliseconds(2));//seconds\n                                                    }\n                                                    obookfile.close();\n                                                    std::cout << \"load completed! Continue...\" << '\\n';\n                                                    str_other_book.pop_back();\n                                                    boost::algorithm::to_lower(str_other_book);\n                                                    std::vector<std::string> split_obS = jsl_j.split_sentences(str_other_book);\n                                                    for(const auto& sobS : split_obS){\n                                                        std::string str_check = sobS;\n                                                        if(str_check.find(s_addd)!=std::string::npos){\n                                                            std::pair<std::string,std::string> pickedPhrase = std::make_pair(s_addd,str_check);\n                                                            /*\n                                                                check if the target word is the last word, if it's the last word, continue;\n                                                            */\n                                                            std::cout << s_addd <<\" >>>> \" <<  str_check << '\\n'; \n                                                            //phrases_picked.push_back(pickedPhrase);\n                                                        }\n                                                    }\n                                                }\n                                            }\n                                        }\n                                        //std::this_thread::sleep_for(std::chrono::milliseconds(5));//seconds \n                                    }\n                                }\n                            }\n                           \n                        }\n                    }\n                }\n            }\n        }\n    }\n\n}\nint main(){\n    nemslib nems_j;\n    nems_j.set_stop_word_file_path(\"/home/ronnieji/lib/lib/res/english_stopwords\");\n    //m_reading(\"/home/ronnieji/corpus/test/Egypt\");\n    m_reading(\"/home/ronnieji/corpus/english_ebooks\");\n    return 0;\n}"
        }
    ]
}